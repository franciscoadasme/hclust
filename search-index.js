crystal_doc_search_index_callback({"repository_name":"hclust","body":"# Fast hierarchical clustering algorithms in pure Crystal\n\n[![Made with Crystal](https://img.shields.io/badge/Made%20with-Crystal-1f425f.svg?logo=crystal)](https://crystal-lang.org)\n[![CI status](https://img.shields.io/github/workflow/status/franciscoadasme/hclust/CI)](https://github.com/franciscoadasme/hclust/actions?query=workflow:CI)\n[![Docs status](https://img.shields.io/github/workflow/status/franciscoadasme/hclust/Deploy%20docs?label=docs)](https://franciscoadasme.github.io/hclust)\n[![Version](https://img.shields.io/github/v/release/franciscoadasme/hclust?label=version)](https://github.com/franciscoadasme/hclust/releases/latest)\n[![License](https://img.shields.io/github/license/franciscoadasme/hclust)](https://github.com/franciscoadasme/hclust/blob/master/LICENSE)\n\nThis shard provides types and methods for fast hierarchical agglomerative\nclustering featuring efficient linkage algorithms.\n\nThe current implementation is heavily based on the work of Daniel Müllner [[1]]\nand derived from Müllner's own implementation found in the [fastcluster] C++\nlibrary [[2]], and parts of the implementation were also inspired by the\n[kodama] Rust crate (code for updating distances) and [SciPy] Python library\n(code for generating flat clusters).\n\nThe runtime performance of this library is on par with the reference implementations (see [benchmark](#benchmark)).\n\nThe most relevant types and methods for practical usage are the\nfollowing:\n\n- `.cluster` performs hierarchical clustering of a set of elements using the\n  pairwise dissimilarities returned by the given block.\n- `.linkage` performs hierarchical clustering based on a pairwise\n  `DistanceMatrix` returning a `Dendrogram` as output.\n- `Rule` is an enum that determines the linkage criterion or rule.\n- `Dendrogram` represents a step-wise dendrogram that encodes the\n  hierarchy of clusters obtained from hierarchical clustering.\n- `Dendrogram#flatten` returns a list of flat clusters.\n\nThe available linkage rules are:\n\n- Average or UPGMA method.\n- Centroid or UPGMC method.\n- Complete or farthest neighbor method.\n- Median or WPGMC method.\n- Single or nearest neighbor method.\n- Ward's minimum variance method\n- Weighted or WPGMA method.\n\nThis library is released under the MIT license.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     hclust:\n       github: franciscoadasme/hclust\n   ```\n\n2. Run `shards install`\n\n## Usage\n\nFirst define the data points to be clustered:\n\n```crystal\ncoords = [\n  [-0.30818828, 2.70462841, 1.84344886],\n  [2.9666203, -1.39874721, 4.76223947],\n  [3.21737027, 4.09489028, -4.60403434],\n  [-3.51140292, -0.83953645, 2.31887739],\n  [2.08457843, 4.24960773, -3.91378835],\n  [2.88992367, -0.97659082, 0.75464131],\n  [0.43808545, 3.70042294, 4.99126146],\n  [-1.71676206, 4.93399583, 0.27392482],\n  [1.12130963, -1.09646418, 1.45833231],\n  [-3.45524705, 0.92812111, 0.15155981],\n]\nlabels = (0...coords.size).to_a # for demonstration purposes\n```\n\nThe easiest way is to use the convenience method `#cluster`. The following code\nwill cluster the data points into groups based on the Euclidean distance with a\ndistance cutoff of 4 using the single linkage (default so can be omitted):\n\n```crystal\nrequire \"hclust\"\n\nclusters = HClust.cluster(labels, 4, :single) { |i, j|\n  Math.sqrt (0...u.size).sum { |i| (u[i] - v[i])**2 } # euclidean distance\n}\nclusters.size # => 3\nclusters      # => [[0, 3, 6, 7, 9], [1, 5, 8], [2, 4]]\n```\n\nUse the `into:` named argument to limit the number of clusters:\n\n```crystal\nclusters = HClust.cluster(labels, into: 2) { |i, j|\n  Math.sqrt (0...u.size).sum { |i| (u[i] - v[i])**2 } # euclidean distance\n}\nclusters.size # => 2\nclusters      # => [[0, 1, 3, 5, 6, 7, 8, 9], [2, 4]]\n```\n\nAlternatively, the procedure can be replicated by doing each step manually:\n\n```crystal\ndism = DistanceMatrix.new(coords.size) { |i, j|\n  Math.sqrt (0...u.size).sum { |i| (u[i] - v[i])**2 } # euclidean distance\n}\ndendrogram = linkage(dism, :single)\nclusters = dendrogram.flatten(height: 4)\nclusters.size # => 2\nclusters      # => [[0, 1, 3, 5, 6, 7, 8, 9], [2, 4]]\n```\n\nThe latter can be useful to avoid recomputing the recomputing the\ndissimilarities when testing different clustering arguments, or obtaining the\ndendrogram can be useful for visual inspection.\n\nRefer to the [API documentation] for further details.\n\n## Benchmark\n\nA Bash script is used to benchmark the code and be compared against reference implementations. Run the following command on the project folder:\n\n```shell\nbash bench/bench.sh\n```\n\nThis will download the required libraries (except for SciPy which must be\navailable in the current Python environment) temporary to run the corresponding\ncode. Each benchmark will run for a number of times, and the best time will be\nprinted out.\n\nThe expected output was tested on a AMD® Ryzen 9 5950x under Pop!_OS 22.04 LTS with default values:\n\n| name         | version | compiler     | time (ms) |\n| ------------ | ------- | ------------ | --------- |\n| fastcluster  | 1.2.6   | 11.2.0 (gcc) |     0.032 |\n| kodama       | 0.2.3   | 1.61.0       |     0.041 |\n| scipy        | 1.7.3   | 3.9.12       |     0.094 |\n| hclust       | 0.1.0   | 1.4.1        |     0.067 |\n\nThe benchmark can be configured via environment variables:\n\n- `BENCH_SIZE` sets the number of data points to bench (defaults to 100).\n- `BENCH_REPEATS` sets the number of times to repeat the code during benchmark\n  (defaults to 1000).\n- `BENCH_RULE` sets the linkage rule to run: `average`, `centroid`, `complete`,\n  `median`, `single`, `ward` (default), or `weighted`.\n- `BENCH_METHOD` sets the clustering method to run: `mst`, `chain`, or `generic`\n  (default).\n\n## Contributing\n\n1. Fork it (<https://github.com/franciscoadasme/hclust/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Francisco Adasme](https://github.com/franciscoadasme) - creator and maintainer\n\n[1]: https://arxiv.org/abs/1109.2378\n[2]: https://doi.org/10.18637/jss.v053.i09\n[API documentation]: https://franciscoadasme.github.io/hclust\n[fastcluster]: https://github.com/dmuellner/fastcluster\n[kodama]: https://github.com/diffeo/kodama\n[SciPy]:\n    https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.fcluster.html","program":{"html_id":"hclust/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"locations":[],"repository_name":"hclust","program":true,"enum":false,"alias":false,"const":false,"types":[{"html_id":"hclust/HClust","path":"HClust.html","kind":"module","full_name":"HClust","name":"HClust","abstract":false,"locations":[{"filename":"src/hclust.cr","line_number":214,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust.cr#L214"},{"filename":"src/hclust/dendrogram.cr","line_number":3,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L3"},{"filename":"src/hclust/version.cr","line_number":1,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/version.cr#L1"}],"repository_name":"hclust","program":false,"enum":false,"alias":false,"const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"{{ (`shards version \\\"/home/runner/work/hclust/hclust/src/hclust\\\"`).chomp.stringify }}"}],"doc":"The `HClust` module provides methods for fast hierarchical\nagglomerative clustering featuring efficient linkage algorithms.\n\nCluster analysis or [clustering] arrange a set of objects into\ndistinct groups or clusters such that the elements within a cluster\nare more similar to each other than those in other clusters based on a\ngiven criterion. The latter is defined as a measure of dissimilarity\nbetween the objects, and it's usually encoded in a `DistanceMatrix`.\nHierarchical agglomerative clustering builds a hierarchy of clusters,\nwhere each object or element starts in its own cluster, and then they\nare progressively merged forming a hierarchy among them. The\ndissimilarities bewteen a newly-created cluster and all other clusters\nare updated after each merging step. The dissimilarity between two\nclusters is dictated by the chosen linkage criterion or rule. The\nobtained hierarchy is often encoded as a `Dendrogram`, which can be\ncut at a given dissimilarity value to obtain flat clusters such that\nthe elements of a flat cluster have a cophenetic distance no greater\nthan the given value (see `Dendrogram#flatten`).\n\nThe standard algorithm has a time complexity of Θ(*N*³), which is\nimplemented by the `.primitive` method. However, optimal algorithms\nare provided based on the work of Daniel Müllner [[1]], which\ndescribes several optimizations over the standard algorithm\n(implemented by the `.generic` method), and fast methods for special\ncases such as the minimum spanning tree (MST) method (`.mst`) for\nsingle linkage and nearest-neighbor-chain (NN-chain) method\n(`.nn_chain`) for average, complete, Ward's, and weighted linkage.\nThus, the best-case complexity can be reduced to Θ(*N*²), where, in\npractice, the runtime of the general case is close to this.\n\nThe current implementation is heavily based on Müllner's own\nimplementation found in the [fastcluster] C++ library, and parts of\nthe implementation were also inspired by the [kodama] Rust crate (code\nfor updating distances) and [SciPy] Python library (code for\ngenerating flat clusters).\n\nThe most relevant types and methods for practical usage are the\nfollowing:\n\n- `.cluster` performs hierarchical clustering of a set of elements\n  using the pairwise dissimilarities returned by the given block.\n- `.linkage` performs hierarchical clustering based on a pairwise\n  `DistanceMatrix` returning a `Dendrogram` as output.\n- `Rule` is an enum that determines the linkage criterion or rule.\n- `Dendrogram` represents a step-wise dendrogram that encodes the\n  hierarchy of clusters obtained from hierarchical clustering.\n- `Dendrogram#flatten` returns a list of flat clusters.\n\nThe available linkage rules are:\n\n- `Rule::Average` or UPGMA method.\n- `Rule::Centroid` or UPGMC method.\n- `Rule::Complete` or farthest neighbor method.\n- `Rule::Median` or WPGMC method.\n- `Rule::Single` or nearest neighbor method.\n- `Rule::Ward`'s minimum variance method\n- `Rule::Weighted` or WPGMA method.\n\nSee `Rule` documentation for details.\n\n### Clustering example\n\nLet's first define a list of random coordinates in 3D space as an\nexample case:\n\n```\ncoords = [\n  [-0.30818828, 2.70462841, 1.84344886],\n  [2.9666203, -1.39874721, 4.76223947],\n  [3.21737027, 4.09489028, -4.60403434],\n  [-3.51140292, -0.83953645, 2.31887739],\n  [2.08457843, 4.24960773, -3.91378835],\n  [2.88992367, -0.97659082, 0.75464131],\n  [0.43808545, 3.70042294, 4.99126146],\n  [-1.71676206, 4.93399583, 0.27392482],\n  [1.12130963, -1.09646418, 1.45833231],\n  [-3.45524705, 0.92812111, 0.15155981],\n]\nlabels = (0...coords.size).to_a # for demonstration purposes\n```\n\nWe'd like to group them by the proximity to each other defined by\nEuclidean distance:\n\n```\ndef euclidean(u, v)\n  Math.sqrt (0...u.size).sum { |i| (u[i] - v[i])**2 }\nend\n```\n\nLet's say we want to split the coordinates into groups with a distance\nno more than 4. The easiest way is to use the `.cluster` convenience\nmethod:\n\n```\nclusters = HClust.cluster(labels, 4) { |i, j| euclidean(coords[u], coords[v]) }\nclusters.size # => 3\nclusters      # => [[0, 3, 6, 7, 9], [1, 5, 8], [2, 4]]\n```\n\nThe method receives the elements to be clustered, a distance cutoff,\nand a block that receives two of the elements and must return the\ndissimilarity between them. We observe that the coordinates can be\ngrouped into 3 distinct clusters containing 5, 3, and 2 elements,\nrespectively. The order of the clusters is arbitrary and depends on\nthe order of the elements.\n\nAlternatively, one can set the maximum number of clusters to be\ngenerated instead of a distance cutoff using the named argument\n`into:`:\n\n```\nclusters = HClust.cluster(labels, into: 2) { |i, j| euclidean(coords[i], coords[j]) }\nclusters.size # => 2\nclusters      # => [[0, 1, 3, 5, 6, 7, 8, 9], [2, 4]]\n```\n\nAs stated above, the linkage rule dictates how the dissimilarities are\nupdated upon merging two clusters during the clustering procedure.\nTherefore, the clustering output will depend on the selected rule. In\nturn, the choice of the linkage rule depends both on the problem\ndomain and performance requirements. By default, the single linkage is\nused throughout the code but it can be given as the third (optional)\nargument to the cluster methods if required.\n\n```\nclusters = HClust.cluster(labels, 2, :centroid) { |i, j|\n  euclidean(coords[i], coords[j])\n}\nclusters.size # => 5\nclusters      # => [[0, 7], [1, 5, 8], [2, 4], [3, 9], [6]]\n```\n\nNote the different number of clusters and composition obtained with\nthe centroid linkage comparted to the previous result using the single\nlinkage.\n\n### Advanced usage\n\nUsing the `.cluster` methods is enough in most cases, albeit obtaining\nthe dendrogram can be useful for visualization purposes or testing\ndifferent clustering arguments without recomputing the\ndissimilarities.\n\nUnder the hood, the `.cluster` methods construct a `DistanceMatrix`\nwith the given block, invoke the `.linkage` method, and then call\n`Dendrogram#flatten` on the obtained dendrogram with the given\nargument. The latter returns an array of clusters, each containing a\nlist of indexes that can be used to fetch the original elements. The\nequivalent code to the above example would be:\n\n```\ndism = DistanceMatrix.new(coords.size) { |i, j| euclidean(coords[i], coords[j]) }\ndendrogram = linkage(dism)\nclusters = dendrogram.flatten(4)\n```\n\nThe dendrogram represents the hierarchy as a series of merge steps,\nwhich contain the merged clusters and computed dissimilarity. For\ninstance, let's see what the dendrogram looks like:\n\n```\npp dendrogram.steps.map { |s| [s.clusters[0], s.clusters[1], s.distance, 0.0] }\n```\n\nwill print:\n\n```text\n# cluster1, cluster2, dissimilarity, size (unused)\n[[2, 4, 1.3355127737375514, 0.0],\n [5, 8, 1.9072352420201895, 0.0],\n [3, 9, 2.7973259058854163, 0.0],\n [0, 7, 3.068805125647255, 0.0],\n [6, 13, 3.384856775520168, 0.0],\n [1, 11, 3.796359969884454, 0.0],\n [12, 14, 3.9902939298123274, 0.0],\n [15, 16, 4.079225895869359, 0.0],\n [10, 17, 5.696974476555648, 0.0]]\n```\n\nThe output can be copied into a Python terminal and visualized using\nthe [dendrogram] function in [SciPy] or similar software. It would\nlook something like:\n\n```text\n  |       ________________\n5 |      |                |\n  |      |                |\n4 |      |         _______|_______\n  |      |      __|__         ____|___\n3 |      |     |     |       |      __|__\n  |      |     |     |      _|_    |    _|_\n2 |      |     |    _|_    |   |   |   |   |\n  |      |     |   |   |   |   |   |   |   |\n1 |     _|_    |   |   |   |   |   |   |   |\n  |    |   |   |   |   |   |   |   |   |   |\n0 |    2   4   1   5   8   3   9   6   0   7\n```\n\nUsing this graph, one can deduce the optimal cutoff for generating\nflat clusters, where a cutoff = 4 would produce indeed two clusters as\nshown above.\n\n[1]: https://arxiv.org/abs/1109.2378\n[clustering]: https://en.wikipedia.org/wiki/Cluster_analysis\n[fastcluster]: https://github.com/dmuellner/fastcluster\n[kodama]: https://github.com/diffeo/kodama\n[SciPy]:\n    https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.fcluster.html\n[dendrogram]:\n    https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.dendrogram.html","summary":"<p>The <code><a href=\"HClust.html\">HClust</a></code> module provides methods for fast hierarchical agglomerative clustering featuring efficient linkage algorithms.</p>","class_methods":[{"html_id":"cluster(elements:Indexable(T),cutoff:Number,rule:Rule=:single,&:T,T->Float64):Array(Array(T))forallT-class-method","name":"cluster","doc":"Clusters *elements* using the linkage rule *rule* based on the\ndistances computed by the given block. The clusters are generated such\nthat the cophenetic distance between any two elements in a cluster is\nless than or equal to *cutoff*.","summary":"<p>Clusters <em>elements</em> using the linkage rule <em>rule</em> based on the distances computed by the given block.</p>","abstract":false,"args":[{"name":"elements","external_name":"elements","restriction":"Indexable(T)"},{"name":"cutoff","external_name":"cutoff","restriction":"Number"},{"name":"rule","default_value":":single","external_name":"rule","restriction":"Rule"}],"args_string":"(elements : Indexable(T), cutoff : Number, rule : Rule = :single, & : T, T -> Float64) : Array(Array(T)) forall T","args_html":"(elements : Indexable(T), cutoff : Number, rule : <a href=\"HClust/Rule.html\">Rule</a> = <span class=\"n\">:single</span>, & : T, T -> Float64) : Array(Array(T)) forall T","location":{"filename":"src/hclust/cluster.cr","line_number":5,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/cluster.cr#L5"},"def":{"name":"cluster","args":[{"name":"elements","external_name":"elements","restriction":"Indexable(T)"},{"name":"cutoff","external_name":"cutoff","restriction":"Number"},{"name":"rule","default_value":":single","external_name":"rule","restriction":"Rule"}],"yields":2,"block_arg":{"name":"","external_name":"","restriction":"(T, T -> Float64)"},"return_type":"Array(Array(T))","visibility":"Public","body":"dism = DistanceMatrix.new(elements.size) do |i, j|\n  yield elements[i], elements[j]\nend\ndendrogram = linkage(dism, rule, reuse: true)\n(dendrogram.flatten(cutoff)).map do |idxs|\n  idxs.map do |i|\n    elements[i]\n  end\nend\n"}},{"html_id":"cluster(elements:Indexable(T),*,intocount:Int,rule:Rule=:single,&:T,T->Float64):Array(Array(T))forallT-class-method","name":"cluster","doc":"Clusters *elements* into *count* clusters or fewer using the linkage\nrule *rule* based on the distances computed by the given block.","summary":"<p>Clusters <em>elements</em> into <em>count</em> clusters or fewer using the linkage rule <em>rule</em> based on the distances computed by the given block.</p>","abstract":false,"args":[{"name":"elements","external_name":"elements","restriction":"Indexable(T)"},{"name":"","external_name":"","restriction":""},{"name":"count","external_name":"into","restriction":"Int"},{"name":"rule","default_value":":single","external_name":"rule","restriction":"Rule"}],"args_string":"(elements : Indexable(T), *, into count : Int, rule : Rule = :single, & : T, T -> Float64) : Array(Array(T)) forall T","args_html":"(elements : Indexable(T), *, into count : Int, rule : <a href=\"HClust/Rule.html\">Rule</a> = <span class=\"n\">:single</span>, & : T, T -> Float64) : Array(Array(T)) forall T","location":{"filename":"src/hclust/cluster.cr","line_number":24,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/cluster.cr#L24"},"def":{"name":"cluster","args":[{"name":"elements","external_name":"elements","restriction":"Indexable(T)"},{"name":"","external_name":"","restriction":""},{"name":"count","external_name":"into","restriction":"Int"},{"name":"rule","default_value":":single","external_name":"rule","restriction":"Rule"}],"splat_index":1,"yields":2,"block_arg":{"name":"","external_name":"","restriction":"(T, T -> Float64)"},"return_type":"Array(Array(T))","visibility":"Public","body":"dism = DistanceMatrix.new(elements.size) do |i, j|\n  yield elements[i], elements[j]\nend\ndendrogram = linkage(dism, rule, reuse: true)\ndendrogram.flatten(count: count).map do |idxs|\n  idxs.map do |i|\n    elements[i]\n  end\nend\n"}},{"html_id":"generic(dism:DistanceMatrix,rule:Rule):Dendrogram-class-method","name":"generic","doc":"Perform hierarchical clustering based on the distances stored in\n*dism* using a fast generic linkage algorithm with the given linkage\nrule.\n\nThe so-called generic algorithm published by Müllner, D.\n[[1]](https://arxiv.org/abs/1109.2378) includes several optimizations\nover the classic hierarchical clustering algorithm, reducing the\nbest-case complexity from Θ(*N*³) to Θ(*N*²). In practice, it is\nconsiderably faster than the standard method. This is mainly due to\nthe algorithm keeps track of the nearest neighbors of clusters in a\npriority queue to speed up the repeated minimum searches.\n\nThis algorithm can deal with inversions in the dendrogram, so it can\nbe used with any linkage rule including `Rule::Centroid` and\n`Rule::Median`.\n\nThe merge steps are encoded as an unordered `Dendrogram`, which is\nsorted prior to be returned.\n\nThe current implementation is described in section 3.1 of the\nMüllner's article [[1]](https://arxiv.org/abs/1109.2378).\n\nNOTE: Prefer to use the `.linkage` method since it provides a general\ninterface and picks the best algorithm depending on the linkage rule.","summary":"<p>Perform hierarchical clustering based on the distances stored in <em>dism</em> using a fast generic linkage algorithm with the given linkage rule.</p>","abstract":false,"args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"},{"name":"rule","external_name":"rule","restriction":"Rule"}],"args_string":"(dism : DistanceMatrix, rule : Rule) : Dendrogram","args_html":"(dism : <a href=\"HClust/DistanceMatrix.html\">DistanceMatrix</a>, rule : <a href=\"HClust/Rule.html\">Rule</a>) : <a href=\"HClust/Dendrogram.html\">Dendrogram</a>","location":{"filename":"src/hclust/generic.cr","line_number":25,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/generic.cr#L25"},"def":{"name":"generic","args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"},{"name":"rule","external_name":"rule","restriction":"Rule"}],"return_type":"Dendrogram","visibility":"Public","body":"if rule.needs_squared_euclidean?\n  dism.map!(&.**(2))\nend\nactive_nodes = IndexList.new(dism.size)\nsizes = Pointer(Int32).malloc(dism.size, 1)\nnearest = Pointer(Int32).malloc(dism.size)\nqueue = IndexPriorityQueue.new(dism.size) do |i|\n  if i < (dism.size - 1)\n    nearest[i] = ((i + 1)...dism.size).min_by do |j|\n      dism.unsafe_fetch(i, j)\n    end\n    dism.unsafe_fetch(i, nearest[i])\n  else\n    Float64::MAX\n  end\nend\ndendrogram = Dendrogram.new(dism.size)\n(dism.size - 1).times do\n  if rule.single?\n  else\n    update_nearest(active_nodes, dism, nearest, queue)\n  end\n  step = next_merge(dism, nearest, queue)\n  {% if true %}\n      case rule\n      {% for rule in HClust::Rule.constants.map do |__arg1|\n    __arg1.id.downcase\n  end %}\n        in .{{ rule }}?\n          update_distances_{{ rule }}(active_nodes, dism, sizes, nearest, queue, *step.clusters)\n      {% end %}\n      end\n    {% end %}\n  __temp_67 = step.clusters[1]\n  sizes[__temp_67] = sizes[__temp_67] + sizes[step.clusters[0]]\n  active_nodes.delete(step.clusters[0])\n  if rule.needs_squared_euclidean?\n    step = step.sqrt\n  end\n  dendrogram << step\nend\ndendrogram.relabel(ordered: !rule.order_dependent?)\n"}},{"html_id":"linkage(dism:DistanceMatrix,rule:Rule,reuse:Bool=false):Dendrogram-class-method","name":"linkage","doc":"Returns the hierarchical clustering based on the pairwise distances\n*dism* using the linkage rule *rule*.\n\nThis method simply selects and invokes the optimal algorithm based on\nthe given linkage rule as follows:\n\n- The minimum spanning tree (MST) algoritm for the `Rule::Single`\n  linkage rule (see `.mst`).\n- The nearest-neighbor-chain (NN-chain) algoritm for the\n  `Rule::Complete`, `Rule::Average`, `Rule::Weighted`, and\n  `Rule::Ward` linkage rules (`.nn_chain`).\n- The generic algoritm for the `Rule::Centroid` and `Rule::Median`\n  linkage rules (`.generic`).\n\nIf *reuse* is `true`, the distance matrix *dism* will be forwarded\ndirectly to the underlying method, and be potentially modified. If\n*reuse* is `false`, a copy will be created first and then forwarded.\nThis can be used to prevent a potentially large memory allocation when\nthe distance matrix will not be used after clustering.","summary":"<p>Returns the hierarchical clustering based on the pairwise distances <em>dism</em> using the linkage rule <em>rule</em>.</p>","abstract":false,"args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"},{"name":"rule","external_name":"rule","restriction":"Rule"},{"name":"reuse","default_value":"false","external_name":"reuse","restriction":"Bool"}],"args_string":"(dism : DistanceMatrix, rule : Rule, reuse : Bool = false) : Dendrogram","args_html":"(dism : <a href=\"HClust/DistanceMatrix.html\">DistanceMatrix</a>, rule : <a href=\"HClust/Rule.html\">Rule</a>, reuse : Bool = <span class=\"n\">false</span>) : <a href=\"HClust/Dendrogram.html\">Dendrogram</a>","location":{"filename":"src/hclust/linkage.cr","line_number":20,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/linkage.cr#L20"},"def":{"name":"linkage","args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"},{"name":"rule","external_name":"rule","restriction":"Rule"},{"name":"reuse","default_value":"false","external_name":"reuse","restriction":"Bool"}],"return_type":"Dendrogram","visibility":"Public","body":"if reuse\nelse\n  dism = dism.clone\nend\ncase rule\nin .single?\n  mst(dism)\nin .average?, .complete?, .ward?, .weighted?\n  nn_chain(dism, rule.to_chain)\nin .centroid?, .median?\n  generic(dism, rule)\nend\n"}},{"html_id":"mst(dism:DistanceMatrix):Dendrogram-class-method","name":"mst","doc":"Perform hierarchical clustering based on the distances stored in\n*dism* using the minimum spanning tree (MST) algorithm.\n\nThe MST algorithm keeps track of the distances to the nearest neighbor\nfor each cluster after every merge step, which leads to a significant\nspeed up as obtaining the next pair of nearest clusters is very\nefficient. By definition, this algorithm can only be used with the\n`Rule::Single` linkage rule.\n\nThe merge steps are encoded as an unordered `Dendrogram`, which is\nsorted prior to be returned.\n\nThe current implementation is described in section 3.3 of the\nMüllner's article [[1]](https://arxiv.org/abs/1109.2378), which\nincludes several optimizations over the classic implementation.\n\nNOTE: Prefer to use the `.linkage` method since it provides a general\ninterface and picks the best algorithm depending on the linkage rule.","summary":"<p>Perform hierarchical clustering based on the distances stored in <em>dism</em> using the minimum spanning tree (MST) algorithm.</p>","abstract":false,"args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"}],"args_string":"(dism : DistanceMatrix) : Dendrogram","args_html":"(dism : <a href=\"HClust/DistanceMatrix.html\">DistanceMatrix</a>) : <a href=\"HClust/Dendrogram.html\">Dendrogram</a>","location":{"filename":"src/hclust/mst.cr","line_number":19,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/mst.cr#L19"},"def":{"name":"mst","args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"}],"return_type":"Dendrogram","visibility":"Public","body":"active_nodes = IndexList.new(dism.size)\nmerged_dis_ptr = Pointer(Float64).malloc(dism.size)\n(merged_dis_ptr + 1).copy_from(dism.to_unsafe, dism.size - 1)\ndendrogram = Dendrogram.new(dism.size)\nn_i = 0\n(dism.size - 1).times do\n  active_nodes.delete(n_i)\n  n_j, d_ij = active_nodes.nearest_to(n_i, dism) do |n_k, dis|\n    ptr = merged_dis_ptr + n_k\n    Rule.single(0, dis, ptr, 0, 0, 0)\n    ptr.value\n  end\n  dendrogram.add(n_i, n_j, d_ij)\n  n_i = n_j\nend\ndendrogram.relabel(ordered: true)\n"}},{"html_id":"nn_chain(dism:DistanceMatrix,rule:ChainRule):Dendrogram-class-method","name":"nn_chain","doc":"Perform hierarchical clustering based on the distances stored in\n*dism* using the nearest-neighbor-chain (NN-chain) algorithm with the\ngiven linkage rule.\n\nThe NN-chain algorithm follows paths in the nearest neighbor graph of\nthe clusters to find a pair of clusters that are nearest neighbors of\neach other, which are merged into a new cluster. The algorithm uses a\nstack data structure (`Deque`) to store the paths, which can lead to a\nspeed up by re-using parts of the existing path efficiently.\n\nBy definition, the NN-chain algorithm can only be used with the\nfollowing linkage rules: `Rule::Single`, `Rule::Complete`,\n`Rule::Average`, `Rule::Weighted`, and `Rule::Ward`. Consequently,\nthis method accepts a `ChainRule` enum (not `Rule`), which only\ncontains these methods to ensure safety during compilation.\n\nThe merge steps are encoded as an unordered `Dendrogram`, which is\nsorted prior to be returned.\n\nThe current implementation is described in section 3.2 of the\nMüllner's article [[1]](https://arxiv.org/abs/1109.2378).\n\nNOTE: Prefer to use the `.linkage` method since it provides a general\ninterface and picks the best algorithm depending on the linkage rule.","summary":"<p>Perform hierarchical clustering based on the distances stored in <em>dism</em> using the nearest-neighbor-chain (NN-chain) algorithm with the given linkage rule.</p>","abstract":false,"args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"},{"name":"rule","external_name":"rule","restriction":"ChainRule"}],"args_string":"(dism : DistanceMatrix, rule : ChainRule) : Dendrogram","args_html":"(dism : <a href=\"HClust/DistanceMatrix.html\">DistanceMatrix</a>, rule : <a href=\"HClust/ChainRule.html\">ChainRule</a>) : <a href=\"HClust/Dendrogram.html\">Dendrogram</a>","location":{"filename":"src/hclust/chain.cr","line_number":25,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/chain.cr#L25"},"def":{"name":"nn_chain","args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"},{"name":"rule","external_name":"rule","restriction":"ChainRule"}],"return_type":"Dendrogram","visibility":"Public","body":"rule = rule.to_rule\nif rule.needs_squared_euclidean?\n  dism.map!(&.**(2))\nend\nactive_nodes = IndexList.new(dism.size)\nsizes = Pointer(Int32).malloc(dism.size, 1)\nchain = Deque(Int32).new(dism.size)\ndendrogram = Dendrogram.new(dism.size)\n(dism.size - 1).times do\n  step = next_merge(active_nodes, dism, chain)\n  {% if true %}\n      case rule\n      {% for rule in HClust::ChainRule.constants.map do |__arg1|\n    __arg1.id.downcase\n  end %}\n        when .{{ rule }}?\n          update_distances_{{ rule }}(active_nodes, dism, sizes, *step.clusters)\n      {% end %}\n      end\n    {% end %}\n  __temp_41 = step.clusters[1]\n  sizes[__temp_41] = sizes[__temp_41] + sizes[step.clusters[0]]\n  active_nodes.delete(step.clusters[0])\n  if rule.needs_squared_euclidean?\n    step = step.sqrt\n  end\n  dendrogram << step\nend\ndendrogram.relabel(ordered: !rule.order_dependent?)\n"}},{"html_id":"primitive(dism:DistanceMatrix,rule:Rule):Dendrogram-class-method","name":"primitive","doc":"Perform hierarchical clustering based on the distances stored in\n*dism* using the classic algorithm with the given linkage rule.\n\nThe classic or primitive algorithm iteratively finds a pair of\nclusters that are nearest neighbors of each other, which are merged\ninto a new cluster. Then, the distances stored in *dism* are updated\nby computing the distances to the newly-created cluster according to\nthe linkage rule. The procedure is repeated for *N* - 1 times, where\n*N* is the number of elements or observations. Since all pairwise\ndistances are searched in each iteration, the time complexity of this\nalgorithm is Θ(*N*³).\n\nThis algorithm can deal with inversions in the dendrogram, so it can\nbe used with any linkage rule including `Rule::Centroid` and\n`Rule::Median`.\n\nThe merge steps are encoded as an unordered `Dendrogram`, which is\nsorted prior to be returned.\n\nThe current implementation is described in section 2.4 of the\nMüllner's article [[1]](https://arxiv.org/abs/1109.2378).\n\nWARNING: This method is painfully slow and should not be used for\nproduction. It is only used as reference to test other methods. Prefer\nto use the `.linkage` method since it provides a general interface and\npicks the best algorithm depending on the linkage rule.","summary":"<p>Perform hierarchical clustering based on the distances stored in <em>dism</em> using the classic algorithm with the given linkage rule.</p>","abstract":false,"args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"},{"name":"rule","external_name":"rule","restriction":"Rule"}],"args_string":"(dism : DistanceMatrix, rule : Rule) : Dendrogram","args_html":"(dism : <a href=\"HClust/DistanceMatrix.html\">DistanceMatrix</a>, rule : <a href=\"HClust/Rule.html\">Rule</a>) : <a href=\"HClust/Dendrogram.html\">Dendrogram</a>","location":{"filename":"src/hclust/primitive.cr","line_number":27,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/primitive.cr#L27"},"def":{"name":"primitive","args":[{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"},{"name":"rule","external_name":"rule","restriction":"Rule"}],"return_type":"Dendrogram","visibility":"Public","body":"if rule.needs_squared_euclidean?\n  dism.map!(&.**(2))\nend\nactive_nodes = IndexList.new(dism.size)\nsizes = Pointer(Int32).malloc(dism.size, 1)\ndendrogram = Dendrogram.new(dism.size)\n(dism.size - 1).times do\n  step = next_merge(active_nodes, dism)\n  {% if true %}\n      case rule\n      {% for rule in HClust::Rule.constants.map do |__arg1|\n    __arg1.id.downcase\n  end %}\n        in .{{ rule }}?\n          update_distances_{{ rule }}(active_nodes, dism, sizes, *step.clusters)\n      {% end %}\n      end\n    {% end %}\n  __temp_69 = step.clusters[1]\n  sizes[__temp_69] = sizes[__temp_69] + sizes[step.clusters[0]]\n  active_nodes.delete(step.clusters[0])\n  if rule.needs_squared_euclidean?\n    step = step.sqrt\n  end\n  dendrogram << step\nend\ndendrogram.relabel(ordered: !rule.order_dependent?)\n"}}],"types":[{"html_id":"hclust/HClust/ChainRule","path":"HClust/ChainRule.html","kind":"enum","full_name":"HClust::ChainRule","name":"ChainRule","abstract":false,"ancestors":[{"html_id":"hclust/Enum","kind":"struct","full_name":"Enum","name":"Enum"},{"html_id":"hclust/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"hclust/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"hclust/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/hclust/rule.cr","line_number":254,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L254"}],"repository_name":"hclust","program":false,"enum":true,"alias":false,"const":false,"constants":[{"id":"Average","name":"Average","value":"0"},{"id":"Complete","name":"Complete","value":"1"},{"id":"Single","name":"Single","value":"2"},{"id":"Ward","name":"Ward","value":"3"},{"id":"Weighted","name":"Weighted","value":"4"}],"namespace":{"html_id":"hclust/HClust","kind":"module","full_name":"HClust","name":"HClust"},"doc":"An enum that provides linkage rules supported by the\nnearest-neighbor-chain (`HClust.nn_chain`) algorithm. See `Rule` for\ndetails.","summary":"<p>An enum that provides linkage rules supported by the nearest-neighbor-chain (<code><a href=\"../HClust.html#nn_chain%28dism%3ADistanceMatrix%2Crule%3AChainRule%29%3ADendrogram-class-method\">HClust.nn_chain</a></code>) algorithm.</p>","instance_methods":[{"html_id":"average?-instance-method","name":"average?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":255,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L255"},"def":{"name":"average?","visibility":"Public","body":"self == Average"}},{"html_id":"complete?-instance-method","name":"complete?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":256,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L256"},"def":{"name":"complete?","visibility":"Public","body":"self == Complete"}},{"html_id":"single?-instance-method","name":"single?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":257,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L257"},"def":{"name":"single?","visibility":"Public","body":"self == Single"}},{"html_id":"to_rule:Rule-instance-method","name":"to_rule","doc":"Returns the corresponding linkage rule.","summary":"<p>Returns the corresponding linkage rule.</p>","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":262,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L262"},"def":{"name":"to_rule","return_type":"Rule","visibility":"Public","body":"{% if true %}\n      case self\n      {% for rule in @type.constants %}\n        in .{{ rule.downcase.id }}?\n          Rule::{{ rule.id }}\n      {% end %}\n      end\n    {% end %}"}},{"html_id":"ward?-instance-method","name":"ward?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":258,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L258"},"def":{"name":"ward?","visibility":"Public","body":"self == Ward"}},{"html_id":"weighted?-instance-method","name":"weighted?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":259,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L259"},"def":{"name":"weighted?","visibility":"Public","body":"self == Weighted"}}]},{"html_id":"hclust/HClust/Dendrogram","path":"HClust/Dendrogram.html","kind":"class","full_name":"HClust::Dendrogram","name":"Dendrogram","abstract":false,"superclass":{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"hclust/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/hclust/dendrogram.cr","line_number":23,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L23"}],"repository_name":"hclust","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"hclust/HClust","kind":"module","full_name":"HClust","name":"HClust"},"doc":"A step-wise dendrogram that encodes the arrangement of the clusters\nproduced by hierarchical clustering as a binary tree.\n\nA dendrogram consists of a sequence of *N* - 1 merge steps (see\n`Step`), where *N* is the number of elements or observations that\nwere clustered, and a step corresponds to a merge between two\ndistinct clusters.\n\nThe labeling of the clusters follows the SciPy convention, where new\nlabels start at *N*:\n\n- If a cluster has a single element, the label would be the index of\n  the element in the original sequence.\n- If a cluster has more than one elements (two previous clusters\n  were merged), the label would be *N* + *i*, where *i* is the index\n  of the merge step that created it.\n\nConsequently, the labels of the newly created clusters ranges from\n*N* to *N + N - 1*.","summary":"<p>A step-wise dendrogram that encodes the arrangement of the clusters produced by hierarchical clustering as a binary tree.</p>","constructors":[{"html_id":"new(observations:Int32)-class-method","name":"new","doc":"Creates a new `Dendrogram` with the given number of original\nelements or observations.","summary":"<p>Creates a new <code><a href=\"../HClust/Dendrogram.html\">Dendrogram</a></code> with the given number of original elements or observations.</p>","abstract":false,"args":[{"name":"observations","external_name":"observations","restriction":"Int32"}],"args_string":"(observations : Int32)","args_html":"(observations : Int32)","location":{"filename":"src/hclust/dendrogram.cr","line_number":30,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L30"},"def":{"name":"new","args":[{"name":"observations","external_name":"observations","restriction":"Int32"}],"visibility":"Public","body":"_ = allocate\n_.initialize(observations)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"html_id":"<<(step:Step):self-instance-method","name":"<<","doc":"Appends the given merge step. Raises `ArgumentError` if the\ndendrogram is already full (contains `N - 1` steps).","summary":"<p>Appends the given merge step.</p>","abstract":false,"args":[{"name":"step","external_name":"step","restriction":"Step"}],"args_string":"(step : Step) : self","args_html":"(step : <a href=\"../HClust/Dendrogram/Step.html\">Step</a>) : <span class=\"k\">self</span>","location":{"filename":"src/hclust/dendrogram.cr","line_number":36,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L36"},"def":{"name":"<<","args":[{"name":"step","external_name":"step","restriction":"Step"}],"return_type":"self","visibility":"Public","body":"if @steps.size < (@observations - 1)\nelse\n  raise(ArgumentError.new(\"Dendrogram is full\"))\nend\n@steps << step\nself\n"}},{"html_id":"==(rhs:self):Bool-instance-method","name":"==","doc":"Returns `true` if the merge steps are equal to `rhs`'s steps, else\n`false`.","summary":"<p>Returns <code>true</code> if the merge steps are equal to <code>rhs</code>'s steps, else <code>false</code>.</p>","abstract":false,"args":[{"name":"rhs","external_name":"rhs","restriction":"self"}],"args_string":"(rhs : self) : Bool","args_html":"(rhs : <span class=\"k\">self</span>) : Bool","location":{"filename":"src/hclust/dendrogram.cr","line_number":44,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L44"},"def":{"name":"==","args":[{"name":"rhs","external_name":"rhs","restriction":"self"}],"return_type":"Bool","visibility":"Public","body":"if observations != rhs.observations\n  return false\nend\n@steps.each_with_index do |step, i|\n  if step == (rhs.steps.unsafe_fetch(i))\n  else\n    return false\n  end\nend\ntrue\n"}},{"html_id":"add(c_i:Int32,c_j:Int32,distance:Float64):Step-instance-method","name":"add","doc":"Creates and appends a merge step between clusters *c_i* and *c_j*\nwith the given distance.","summary":"<p>Creates and appends a merge step between clusters <em>c_i</em> and <em>c_j</em> with the given distance.</p>","abstract":false,"args":[{"name":"c_i","external_name":"c_i","restriction":"Int32"},{"name":"c_j","external_name":"c_j","restriction":"Int32"},{"name":"distance","external_name":"distance","restriction":"Float64"}],"args_string":"(c_i : Int32, c_j : Int32, distance : Float64) : Step","args_html":"(c_i : Int32, c_j : Int32, distance : Float64) : <a href=\"../HClust/Dendrogram/Step.html\">Step</a>","location":{"filename":"src/hclust/dendrogram.cr","line_number":54,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L54"},"def":{"name":"add","args":[{"name":"c_i","external_name":"c_i","restriction":"Int32"},{"name":"c_j","external_name":"c_j","restriction":"Int32"},{"name":"distance","external_name":"distance","restriction":"Float64"}],"return_type":"Step","visibility":"Public","body":"step = Step.new(c_i, c_j, distance)\n@steps << step\nstep\n"}},{"html_id":"flatten(height:Number):Array(Array(Int32))-instance-method","name":"flatten","doc":"Returns flat clusters of the original observations obtained by\ncutting the dendrogram at *height* (cophenetic distance).","summary":"<p>Returns flat clusters of the original observations obtained by cutting the dendrogram at <em>height</em> (cophenetic distance).</p>","abstract":false,"args":[{"name":"height","external_name":"height","restriction":"Number"}],"args_string":"(height : Number) : Array(Array(Int32))","args_html":"(height : Number) : Array(Array(Int32))","location":{"filename":"src/hclust/dendrogram.cr","line_number":62,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L62"},"def":{"name":"flatten","args":[{"name":"height","external_name":"height","restriction":"Number"}],"return_type":"Array(Array(Int32))","visibility":"Public","body":"max_dists = max_dist_for_each_cluster(self)\nlabels = cluster_monocrit(self, max_dists, height)\n(0...@observations).to_a.group_by do |i|\n  labels[i]\nend.values\n"}},{"html_id":"flatten(*,count:Int):Array(Array(Int32))-instance-method","name":"flatten","doc":"Returns *count* or fewer flat clusters of the original\nobservations. Raises `ArgumentError` if *count* is negative or\nzero.\n\nIt internally computes the smallest height at which cutting the\ndendrogram would generate *count* or fewer clusters, and then\nflattens the dendrogram at the computed height.","summary":"<p>Returns <em>count</em> or fewer flat clusters of the original observations.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"count","external_name":"count","restriction":"Int"}],"args_string":"(*, count : Int) : Array(Array(Int32))","args_html":"(*, count : Int) : Array(Array(Int32))","location":{"filename":"src/hclust/dendrogram.cr","line_number":75,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L75"},"def":{"name":"flatten","args":[{"name":"","external_name":"","restriction":""},{"name":"count","external_name":"count","restriction":"Int"}],"splat_index":0,"return_type":"Array(Array(Int32))","visibility":"Public","body":"if count > 0\nelse\n  raise(ArgumentError.new(\"Negative or zero count\"))\nend\nmax_dists = max_dist_for_each_cluster(self)\nlabels = cluster_maxclust_monocrit(self, max_dists, count)\n(0...@observations).to_a.group_by do |i|\n  labels[i]\nend.values\n"}},{"html_id":"observations:Int32-instance-method","name":"observations","doc":"Number of the original elements or observations that were\nclustered.","summary":"<p>Number of the original elements or observations that were clustered.</p>","abstract":false,"location":{"filename":"src/hclust/dendrogram.cr","line_number":26,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L26"},"def":{"name":"observations","return_type":"Int32","visibility":"Public","body":"@observations"}},{"html_id":"relabel(ordered:Bool=false):self-instance-method","name":"relabel","doc":"Returns a new `Dendrogram` with relabeled clusters. If *ordered*\nis `true`, the dendrogram's steps will be sorted by the\ndissimilarities first.\n\nInternally, it uses a `UnionFind` data structure for creating\nmerge steps with the new cluster labels efficiently.\n\nNOTE: Cluster labels will follow the SciPy convention, where new\nclusters start at `N` with `N ` equal to the number of\nobservations (see `UnionFind`).","summary":"<p>Returns a new <code><a href=\"../HClust/Dendrogram.html\">Dendrogram</a></code> with relabeled clusters.</p>","abstract":false,"args":[{"name":"ordered","default_value":"false","external_name":"ordered","restriction":"Bool"}],"args_string":"(ordered : Bool = false) : self","args_html":"(ordered : Bool = <span class=\"n\">false</span>) : <span class=\"k\">self</span>","location":{"filename":"src/hclust/dendrogram.cr","line_number":92,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L92"},"def":{"name":"relabel","args":[{"name":"ordered","default_value":"false","external_name":"ordered","restriction":"Bool"}],"return_type":"self","visibility":"Public","body":"steps = @steps\nif ordered\n  steps = steps.sort_by(&.distance)\nend\ndendrogram = self.class.new(@observations)\nset = UnionFind.new(@observations)\nsteps.each do |step|\n  c_i = (set.find(step.clusters[0])).not_nil!\n  c_j = (set.find(step.clusters[1])).not_nil!\n  set.union(c_i, c_j)\n  dendrogram.add(c_i, c_j, step.distance)\nend\ndendrogram\n"}},{"html_id":"steps:Array::View(Step)-instance-method","name":"steps","doc":"Returns a view of the merge steps.","summary":"<p>Returns a view of the merge steps.</p>","abstract":false,"location":{"filename":"src/hclust/dendrogram.cr","line_number":108,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L108"},"def":{"name":"steps","return_type":"Array::View(Step)","visibility":"Public","body":"@steps.view"}}],"types":[{"html_id":"hclust/HClust/Dendrogram/Step","path":"HClust/Dendrogram/Step.html","kind":"struct","full_name":"HClust::Dendrogram::Step","name":"Step","abstract":false,"superclass":{"html_id":"hclust/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"hclust/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"hclust/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"hclust/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/hclust/dendrogram.cr","line_number":118,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L118"}],"repository_name":"hclust","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"hclust/HClust/Dendrogram","kind":"class","full_name":"HClust::Dendrogram","name":"Dendrogram"},"doc":"A single merge step in a dendrogram.\n\nA step corresponds to a merge between two distinct clusters. By\nconvention, the indexes of the merged clusters (`#nodes`) are always\nsorted.","summary":"<p>A single merge step in a dendrogram.</p>","constructors":[{"html_id":"new(c_i:Int32,c_j:Int32,distance:Float64)-class-method","name":"new","doc":"Creates a new *Step* between the clusters *c_i* and *c_j* with\nthe given distance.\n\nNOTE: Cluster indexes are stored sorted.","summary":"<p>Creates a new <em>Step</em> between the clusters <em>c_i</em> and <em>c_j</em> with the given distance.</p>","abstract":false,"args":[{"name":"c_i","external_name":"c_i","restriction":"Int32"},{"name":"c_j","external_name":"c_j","restriction":"Int32"},{"name":"distance","external_name":"distance","restriction":"Float64"}],"args_string":"(c_i : Int32, c_j : Int32, distance : Float64)","args_html":"(c_i : Int32, c_j : Int32, distance : Float64)","location":{"filename":"src/hclust/dendrogram.cr","line_number":135,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L135"},"def":{"name":"new","args":[{"name":"c_i","external_name":"c_i","restriction":"Int32"},{"name":"c_j","external_name":"c_j","restriction":"Int32"},{"name":"distance","external_name":"distance","restriction":"Float64"}],"visibility":"Public","body":"_ = allocate\n_.initialize(c_i, c_j, distance)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"html_id":"==(rhs:self):Bool-instance-method","name":"==","doc":"Returns `true` if the step are equal, else `false`.\n\nNOTE: Distances are compared within numeric precision (epsilon =\n1e-15).","summary":"<p>Returns <code>true</code> if the step are equal, else <code>false</code>.</p>","abstract":false,"args":[{"name":"rhs","external_name":"rhs","restriction":"self"}],"args_string":"(rhs : self) : Bool","args_html":"(rhs : <span class=\"k\">self</span>) : Bool","location":{"filename":"src/hclust/dendrogram.cr","line_number":143,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L143"},"def":{"name":"==","args":[{"name":"rhs","external_name":"rhs","restriction":"self"}],"return_type":"Bool","visibility":"Public","body":"(@clusters == rhsclusters) && (@distance - rhs.distance).abs <= Float64::EPSILON"}},{"html_id":"clusters:Tuple(Int32,Int32)-instance-method","name":"clusters","doc":"Indexes of the merged clusters. An index can range from 0 to *N +\nN - 1*, where *N* is the number of original elements or\nobservations and an index equals to or greater than *N* indicates\na newly created cluster (refer to the `Dendrogram` documentation).","summary":"<p>Indexes of the merged clusters.</p>","abstract":false,"location":{"filename":"src/hclust/dendrogram.cr","line_number":123,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L123"},"def":{"name":"clusters","return_type":"Tuple(Int32, Int32)","visibility":"Public","body":"@clusters"}},{"html_id":"distance:Float64-instance-method","name":"distance","doc":"Distance between the merged clusters. This is computed according\nto the selected linkage rule (see `Rule`) used for the clustering.\nIf both merge clusters have a single element (singleton), the\ndistance is equal to the pairwise distance between the elements.","summary":"<p>Distance between the merged clusters.</p>","abstract":false,"location":{"filename":"src/hclust/dendrogram.cr","line_number":129,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L129"},"def":{"name":"distance","return_type":"Float64","visibility":"Public","body":"@distance"}},{"html_id":"sqrt:self-instance-method","name":"sqrt","doc":"Returns a `Step` with the square root of the distance.","summary":"<p>Returns a <code><a href=\"../../HClust/Dendrogram/Step.html\">Step</a></code> with the square root of the distance.</p>","abstract":false,"location":{"filename":"src/hclust/dendrogram.cr","line_number":148,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/dendrogram.cr#L148"},"def":{"name":"sqrt","return_type":"self","visibility":"Public","body":"self.class.new(*@clusters, Math.sqrt(@distance))"}}]}]},{"html_id":"hclust/HClust/DistanceMatrix","path":"HClust/DistanceMatrix.html","kind":"class","full_name":"HClust::DistanceMatrix","name":"DistanceMatrix","abstract":false,"superclass":{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"hclust/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/hclust/distance.cr","line_number":36,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L36"}],"repository_name":"hclust","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"hclust/HClust","kind":"module","full_name":"HClust","name":"HClust"},"doc":"Stores the pairwise distances between the elements of a set.\n\nA distance matrix is a square, hollow, symmetric, two-dimensional\nmatrix of distances. The latter are assumed to be a *metric*, which is\ndefined by the properties of non-negativity, identity of\nindiscernibles, and triangle inequality [[1]]. However, these\nproperties are not checked.\n\nTo avoid redundancy, the matrix is stored in the condensed form, i.e.,\na one-dimensional array of size `(n * (n - 1)) // 2` that holds the\nupper triangular portion of the matrix. Then, the position of the\ndistance between the elements *i* and *j* in the array is computed as\n`((2 * n - 3 - i) * i >> 1) + j - 1` with `i < j`. Refer to the Notes\nsection in the SciPy documentation of the `squareform` function [[2]].\nUsing the condensed form is useful for implementing optimized\nclustering functions, among others.\n\n### Example\n\n```\n# 5x5 distance matrix\nmat = HClust::DistanceMatrix.new(5) do |i, j|\n  # compute distance between elements i and j\n  10 * (i + 1) + j + 1\nend\nmat[0, 0] # => 0.0 (the distance between the same elements is zero)\nmat[1, 1] # => 0.0\nmat[0, 1] # => 12.0\nmat[1, 0] # => 12.0 (symmetry)\nmat[2, 3] # => 34.0\n```\n\n[1]: https://en.wikipedia.org/wiki/Metric_(mathematics)\n[2]:\n    https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.squareform.html","summary":"<p>Stores the pairwise distances between the elements of a set.</p>","constructors":[{"html_id":"new(size:Int32)-class-method","name":"new","doc":"Creates a new `DistanceMatrix` of the given size filled with zeros.","summary":"<p>Creates a new <code><a href=\"../HClust/DistanceMatrix.html\">DistanceMatrix</a></code> of the given size filled with zeros.</p>","abstract":false,"args":[{"name":"size","external_name":"size","restriction":"Int32"}],"args_string":"(size : Int32)","args_html":"(size : Int32)","location":{"filename":"src/hclust/distance.cr","line_number":41,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L41"},"def":{"name":"new","args":[{"name":"size","external_name":"size","restriction":"Int32"}],"visibility":"Public","body":"_ = allocate\n_.initialize(size)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"html_id":"new(values:Array(Float64))-class-method","name":"new","doc":"Creates a new `DistanceMatrix` from the given condensed distance\nmatrix (one-dimensional array). Raises `ArgumentError` if the given\narray cannot be interpreted as a condensed matrix (it contains an\ninvalid number of elements) or `Enumerable::EmptyError` if it's\nempty.\n\nNOTE: distance values must be valid (non-NaN).","summary":"<p>Creates a new <code><a href=\"../HClust/DistanceMatrix.html\">DistanceMatrix</a></code> from the given condensed distance matrix (one-dimensional array).</p>","abstract":false,"args":[{"name":"values","external_name":"values","restriction":"Array(Float64)"}],"args_string":"(values : Array(Float64))","args_html":"(values : Array(Float64))","location":{"filename":"src/hclust/distance.cr","line_number":53,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L53"},"def":{"name":"new","args":[{"name":"values","external_name":"values","restriction":"Array(Float64)"}],"visibility":"Public","body":"_ = allocate\n_.initialize(values)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"html_id":"new(size:Int32,&:Int32,Int32->Number)-class-method","name":"new","doc":"Creates a new `DistanceMatrix` of the given size and invokes the\ngiven block once for each pair of elements (indexes), using the\nblock's return value as the distance between the given elements.\n\nRaises `ArgumentError` if any distance value is NaN.\n\n```\nHClust::DistanceMatrix.new(5) do |i, j|\n  # compute distance between elements i and j\n  10 * (i + 1) + j + 1\nend\n```","summary":"<p>Creates a new <code><a href=\"../HClust/DistanceMatrix.html\">DistanceMatrix</a></code> of the given size and invokes the given block once for each pair of elements (indexes), using the block's return value as the distance between the given elements.</p>","abstract":false,"args":[{"name":"size","external_name":"size","restriction":"Int32"}],"args_string":"(size : Int32, & : Int32, Int32 -> Number)","args_html":"(size : Int32, & : Int32, Int32 -> Number)","location":{"filename":"src/hclust/distance.cr","line_number":75,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L75"},"def":{"name":"new","args":[{"name":"size","external_name":"size","restriction":"Int32"}],"yields":2,"block_arg":{"name":"","external_name":"","restriction":"(Int32, Int32 -> Number)"},"visibility":"Public","body":"(new(size)).tap do |mat|\n  k = 0\n  (size - 1).times do |i|\n    (i + 1).upto(size - 1) do |j|\n      value = (yield i, j).to_f\n      if value.nan?\n        raise(ArgumentError.new(\"Invalid distance (NaN)\"))\n      end\n      mat.unsafe_put(k, value)\n      k = k + 1\n    end\n  end\nend"}}],"instance_methods":[{"html_id":"==(rhs:self):Bool-instance-method","name":"==","doc":"Returns `true` if the distances of the matrices are equal, else\n`false`.","summary":"<p>Returns <code>true</code> if the distances of the matrices are equal, else <code>false</code>.</p>","abstract":false,"args":[{"name":"rhs","external_name":"rhs","restriction":"self"}],"args_string":"(rhs : self) : Bool","args_html":"(rhs : <span class=\"k\">self</span>) : Bool","location":{"filename":"src/hclust/distance.cr","line_number":135,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L135"},"def":{"name":"==","args":[{"name":"rhs","external_name":"rhs","restriction":"self"}],"return_type":"Bool","visibility":"Public","body":"if @size == rhs.size\nelse\n  return false\nend\n0.upto(@size - 1) do |i|\n  if (unsafe_fetch(i)) == (rhs.unsafe_fetch(i))\n  else\n    return false\n  end\nend\ntrue\n"}},{"html_id":"==(rhs):Bool-instance-method","name":"==","doc":"Returns `true` if the distances of the matrices are equal, else\n`false`.","summary":"<p>Returns <code>true</code> if the distances of the matrices are equal, else <code>false</code>.</p>","abstract":false,"args":[{"name":"rhs","external_name":"rhs","restriction":""}],"args_string":"(rhs) : Bool","args_html":"(rhs) : Bool","location":{"filename":"src/hclust/distance.cr","line_number":144,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L144"},"def":{"name":"==","args":[{"name":"rhs","external_name":"rhs","restriction":""}],"return_type":"Bool","visibility":"Public","body":"false"}},{"html_id":"[](i:Int,j:Int):Float64-instance-method","name":"[]","doc":"Returns the distance between the elements at *i* and *j*. Raises\n`IndexError` if any of the indexes is out of bounds.","summary":"<p>Returns the distance between the elements at <em>i</em> and <em>j</em>.</p>","abstract":false,"args":[{"name":"i","external_name":"i","restriction":"Int"},{"name":"j","external_name":"j","restriction":"Int"}],"args_string":"(i : Int, j : Int) : Float64","args_html":"(i : Int, j : Int) : Float64","location":{"filename":"src/hclust/distance.cr","line_number":92,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L92"},"def":{"name":"[]","args":[{"name":"i","external_name":"i","restriction":"Int"},{"name":"j","external_name":"j","restriction":"Int"}],"return_type":"Float64","visibility":"Public","body":"self[i, j]? || (raise(IndexError.new))"}},{"html_id":"[]=(i:Int,j:Int,value:Float64):Float64-instance-method","name":"[]=","doc":"Sets the distance between the elements at *i* and *j* to *value*.\nReturns *value*.\n\nNegative indices can be used to start counting from the end of the\nelements. Raises `IndexError` if either *i* or *j* is out of bounds,\nor if *i == j* and *value* is not zero.","summary":"<p>Sets the distance between the elements at <em>i</em> and <em>j</em> to <em>value</em>.</p>","abstract":false,"args":[{"name":"i","external_name":"i","restriction":"Int"},{"name":"j","external_name":"j","restriction":"Int"},{"name":"value","external_name":"value","restriction":"Float64"}],"args_string":"(i : Int, j : Int, value : Float64) : Float64","args_html":"(i : Int, j : Int, value : Float64) : Float64","location":{"filename":"src/hclust/distance.cr","line_number":114,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L114"},"def":{"name":"[]=","args":[{"name":"i","external_name":"i","restriction":"Int"},{"name":"j","external_name":"j","restriction":"Int"},{"name":"value","external_name":"value","restriction":"Float64"}],"return_type":"Float64","visibility":"Public","body":"if i == j\n  if value == 0\n    return 0.0\n  else\n    raise(IndexError.new(\"The distances at the diagonal must be zero\"))\n  end\nend\nif i < 0\n  i = i + size\nend\nif j < 0\n  j = j + size\nend\nif (0 <= i && i < size) && (0 <= j && j < size)\n  if j < i\n    i, j = j, i\n  end\n  unsafe_put(i, j, value)\nelse\n  raise(IndexError.new)\nend\n"}},{"html_id":"[]?(i:Int,j:Int):Float64?-instance-method","name":"[]?","doc":"Returns the distance between the elements at *i* and *j*, or `nil` if\nany of the indexes is out of bounds.","summary":"<p>Returns the distance between the elements at <em>i</em> and <em>j</em>, or <code>nil</code> if any of the indexes is out of bounds.</p>","abstract":false,"args":[{"name":"i","external_name":"i","restriction":"Int"},{"name":"j","external_name":"j","restriction":"Int"}],"args_string":"(i : Int, j : Int) : Float64?","args_html":"(i : Int, j : Int) : Float64?","location":{"filename":"src/hclust/distance.cr","line_number":98,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L98"},"def":{"name":"[]?","args":[{"name":"i","external_name":"i","restriction":"Int"},{"name":"j","external_name":"j","restriction":"Int"}],"return_type":"Float64 | ::Nil","visibility":"Public","body":"if i == j\n  return 0.0\nend\nif i < 0\n  i = i + size\nend\nif j < 0\n  j = j + size\nend\nif (0 <= i && i < size) && (0 <= j && j < size)\n  if j < i\n    i, j = j, i\n  end\n  unsafe_fetch(i, j)\nend\n"}},{"html_id":"clone:self-instance-method","name":"clone","doc":"Returns a new `DistanceMatrix` with the same elements as the matrix\n(deep copy).","summary":"<p>Returns a new <code><a href=\"../HClust/DistanceMatrix.html\">DistanceMatrix</a></code> with the same elements as the matrix (deep copy).</p>","abstract":false,"location":{"filename":"src/hclust/distance.cr","line_number":150,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L150"},"def":{"name":"clone","return_type":"self","visibility":"Public","body":"(({{ @type }}).new(size)).tap do |mat|\n  mat.to_unsafe.copy_from(@buffer, @internal_size)\nend"}},{"html_id":"map(&:Float64->Float64):self-instance-method","name":"map","doc":"Returns a new `DistanceMatrix` with the results of running the block\nagainst each element of the matrix.","summary":"<p>Returns a new <code><a href=\"../HClust/DistanceMatrix.html\">DistanceMatrix</a></code> with the results of running the block against each element of the matrix.</p>","abstract":false,"location":{"filename":"src/hclust/distance.cr","line_number":158,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L158"},"def":{"name":"map","yields":1,"block_arg":{"name":"","external_name":"","restriction":"(Float64 -> Float64)"},"return_type":"self","visibility":"Public","body":"clone.map! do |distance|\n  yield distance\nend"}},{"html_id":"map!(&:Float64->Float64):self-instance-method","name":"map!","doc":"Invokes the given block for each element of the distance matrix,\nreplacing the element with the value returned by the block. Returns\n`self`.","summary":"<p>Invokes the given block for each element of the distance matrix, replacing the element with the value returned by the block.</p>","abstract":false,"location":{"filename":"src/hclust/distance.cr","line_number":165,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L165"},"def":{"name":"map!","yields":1,"block_arg":{"name":"","external_name":"","restriction":"(Float64 -> Float64)"},"return_type":"self","visibility":"Public","body":"@internal_size.times do |i|\n  unsafe_put(i, yield unsafe_fetch(i))\nend\nself\n"}},{"html_id":"matrix_to_condensed_index(row:Int32,col:Int32):Int32-instance-method","name":"matrix_to_condensed_index","doc":"Returns the condensed matrix index of the distance between the\nelements at *i* and *j*.","summary":"<p>Returns the condensed matrix index of the distance between the elements at <em>i</em> and <em>j</em>.</p>","abstract":false,"args":[{"name":"row","external_name":"row","restriction":"Int32"},{"name":"col","external_name":"col","restriction":"Int32"}],"args_string":"(row : Int32, col : Int32) : Int32","args_html":"(row : Int32, col : Int32) : Int32","location":{"filename":"src/hclust/distance.cr","line_number":175,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L175"},"def":{"name":"matrix_to_condensed_index","args":[{"name":"row","external_name":"row","restriction":"Int32"},{"name":"col","external_name":"col","restriction":"Int32"}],"return_type":"Int32","visibility":"Public","body":"{% if !(flag?(:release)) %}\n      # The condensed matrix encodes the upper right triangle, so `row < col`.\n      raise ArgumentError.new(\"row >= column\") if row >= col\n    {% end %}\n((((((2 * @size) - 3) - row) * row) >> 1) + col) - 1\n"}},{"html_id":"size:Int32-instance-method","name":"size","doc":"Returns the size of the encoded matrix.","summary":"<p>Returns the size of the encoded matrix.</p>","abstract":false,"location":{"filename":"src/hclust/distance.cr","line_number":188,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L188"},"def":{"name":"size","return_type":"Int32","visibility":"Public","body":"@size"}},{"html_id":"to_a:Array(Float64)-instance-method","name":"to_a","doc":"Returns the condensed distance matrix as an array.","summary":"<p>Returns the condensed distance matrix as an array.</p>","abstract":false,"location":{"filename":"src/hclust/distance.cr","line_number":193,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L193"},"def":{"name":"to_a","return_type":"Array(Float64)","visibility":"Public","body":"Array(Float64).build(@internal_size) do |buffer|\n  buffer.copy_from(@buffer, @internal_size)\n  @internal_size\nend"}},{"html_id":"to_unsafe(row:Int32,col:Int32):Pointer(Float64)-instance-method","name":"to_unsafe","doc":"Returns a pointer to the internal buffer placed at the specified\nlocation.","summary":"<p>Returns a pointer to the internal buffer placed at the specified location.</p>","abstract":false,"args":[{"name":"row","external_name":"row","restriction":"Int32"},{"name":"col","external_name":"col","restriction":"Int32"}],"args_string":"(row : Int32, col : Int32) : Pointer(Float64)","args_html":"(row : Int32, col : Int32) : Pointer(Float64)","location":{"filename":"src/hclust/distance.cr","line_number":207,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L207"},"def":{"name":"to_unsafe","args":[{"name":"row","external_name":"row","restriction":"Int32"},{"name":"col","external_name":"col","restriction":"Int32"}],"return_type":"Pointer(Float64)","visibility":"Public","body":"@buffer + (matrix_to_condensed_index(row, col))"}},{"html_id":"to_unsafe:Pointer(Float64)-instance-method","name":"to_unsafe","doc":"Returns a pointer to the internal buffer.","summary":"<p>Returns a pointer to the internal buffer.</p>","abstract":false,"location":{"filename":"src/hclust/distance.cr","line_number":201,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L201"},"def":{"name":"to_unsafe","return_type":"Pointer(Float64)","visibility":"Public","body":"@buffer"}},{"html_id":"unsafe_fetch(i:Int32,j:Int32):Float64-instance-method","name":"unsafe_fetch","doc":"Returns the distance between the elements at *i* and *j*, without\ndoing any bounds check.\n\nThis should be called with *i* and *j* within `0...size` and `i !=\nj`. Use `#[](i, j)` and `#[]?(i, j)` instead for bounds checking and\nsupport for negative indexes.\n\nNOTE: This method should only be directly invoked if you are\nabsolutely sure *i* and *j* are in bounds, to avoid a bounds check\nfor a small boost of performance.","summary":"<p>Returns the distance between the elements at <em>i</em> and <em>j</em>, without doing any bounds check.</p>","abstract":false,"args":[{"name":"i","external_name":"i","restriction":"Int32"},{"name":"j","external_name":"j","restriction":"Int32"}],"args_string":"(i : Int32, j : Int32) : Float64","args_html":"(i : Int32, j : Int32) : Float64","location":{"filename":"src/hclust/distance.cr","line_number":222,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L222"},"def":{"name":"unsafe_fetch","args":[{"name":"i","external_name":"i","restriction":"Int32"},{"name":"j","external_name":"j","restriction":"Int32"}],"return_type":"Float64","visibility":"Public","body":"unsafe_fetch(matrix_to_condensed_index(i, j))"}},{"html_id":"unsafe_fetch(index:Int):Float64-instance-method","name":"unsafe_fetch","doc":"Returns the distance at the given index of the condensed distance\nmatrix (one-dimensional), without doing any bounds check.\n\nThis should be called with *index* within `0...((size * (size - 1))\n// 2)`.\n\nNOTE: This method should only be directly invoked if you are\nabsolutely sure the index is in bounds, to avoid a bounds check for\na small boost of performance.","summary":"<p>Returns the distance at the given index of the condensed distance matrix (one-dimensional), without doing any bounds check.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int"}],"args_string":"(index : Int) : Float64","args_html":"(index : Int) : Float64","location":{"filename":"src/hclust/distance.cr","line_number":236,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L236"},"def":{"name":"unsafe_fetch","args":[{"name":"index","external_name":"index","restriction":"Int"}],"return_type":"Float64","visibility":"Public","body":"@buffer[index]"}},{"html_id":"unsafe_put(i:Int32,j:Int32,value:Float64):Float64-instance-method","name":"unsafe_put","doc":"Sets the distance between the elements at *i* and *j* to *value*,\nwithout doing any bounds check.\n\nThis should be called with *i* and *j* within `0...size` and `i !=\nj`. Use `#[]=(i, j, value)` instead for bounds checking and support\nfor negative indexes.\n\nNOTE: This method should only be directly invoked if you are\nabsolutely sure *i* and *j* are in bounds, to avoid a bounds check\nfor a small boost of performance.","summary":"<p>Sets the distance between the elements at <em>i</em> and <em>j</em> to <em>value</em>, without doing any bounds check.</p>","abstract":false,"args":[{"name":"i","external_name":"i","restriction":"Int32"},{"name":"j","external_name":"j","restriction":"Int32"},{"name":"value","external_name":"value","restriction":"Float64"}],"args_string":"(i : Int32, j : Int32, value : Float64) : Float64","args_html":"(i : Int32, j : Int32, value : Float64) : Float64","location":{"filename":"src/hclust/distance.cr","line_number":251,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L251"},"def":{"name":"unsafe_put","args":[{"name":"i","external_name":"i","restriction":"Int32"},{"name":"j","external_name":"j","restriction":"Int32"},{"name":"value","external_name":"value","restriction":"Float64"}],"return_type":"Float64","visibility":"Public","body":"unsafe_put(matrix_to_condensed_index(i, j), value)"}},{"html_id":"unsafe_put(index:Int32,value:Float64):Float64-instance-method","name":"unsafe_put","doc":"Sets the distance at the given index of the condensed distance\nmatrix (one-dimensional) to *value*, without doing any bounds check.\n\nThis should be called with *index* within `0...((size * (size - 1))\n// 2)`.\n\nNOTE: This method should only be directly invoked if you are\nabsolutely sure the index is in bounds, to avoid a bounds check for\na small boost of performance.","summary":"<p>Sets the distance at the given index of the condensed distance matrix (one-dimensional) to <em>value</em>, without doing any bounds check.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int32"},{"name":"value","external_name":"value","restriction":"Float64"}],"args_string":"(index : Int32, value : Float64) : Float64","args_html":"(index : Int32, value : Float64) : Float64","location":{"filename":"src/hclust/distance.cr","line_number":265,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/distance.cr#L265"},"def":{"name":"unsafe_put","args":[{"name":"index","external_name":"index","restriction":"Int32"},{"name":"value","external_name":"value","restriction":"Float64"}],"return_type":"Float64","visibility":"Public","body":"@buffer[index] = value"}}]},{"html_id":"hclust/HClust/IndexList","path":"HClust/IndexList.html","kind":"class","full_name":"HClust::IndexList","name":"IndexList","abstract":false,"superclass":{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"hclust/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/hclust/index_list.cr","line_number":16,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L16"}],"repository_name":"hclust","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"hclust/HClust","kind":"module","full_name":"HClust","name":"HClust"},"doc":"An `IndexList` is an ordered collection of contiguous zero-based\nindexes.\n\nIt supports efficient iteration and removal so it performs better than\nan `Array` when there are frequent deletions.\n\nInternally, it is implemented as a double-linked list such that\ndeleted indexes are marked as inactive, but otherwise kept in memory.\nTherefore, indexing is not supported. Traversal is performed using the\n`#each` methods.\n\nThe most typical use case of a `IndexList` is for representing a list\nof nodes, where finding the closest pair is often desired. Hence,\nconvenience methods for finding the nearest index based on a given\ndistance metric are provided.","summary":"<p>An <code><a href=\"../HClust/IndexList.html\">IndexList</a></code> is an ordered collection of contiguous zero-based indexes.</p>","constructors":[{"html_id":"new(size:Int32)-class-method","name":"new","doc":"Creates a new `IndexList` with indexes in the range `[0, size)`.","summary":"<p>Creates a new <code><a href=\"../HClust/IndexList.html\">IndexList</a></code> with indexes in the range <code>[0, size)</code>.</p>","abstract":false,"args":[{"name":"size","external_name":"size","restriction":"Int32"}],"args_string":"(size : Int32)","args_html":"(size : Int32)","location":{"filename":"src/hclust/index_list.cr","line_number":18,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L18"},"def":{"name":"new","args":[{"name":"size","external_name":"size","restriction":"Int32"}],"visibility":"Public","body":"_ = allocate\n_.initialize(size)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"html_id":"delete(index:Int32):Nil-instance-method","name":"delete","doc":"Removes the given index from the list if present.","summary":"<p>Removes the given index from the list if present.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int32"}],"args_string":"(index : Int32) : Nil","args_html":"(index : Int32) : Nil","location":{"filename":"src/hclust/index_list.cr","line_number":96,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L96"},"def":{"name":"delete","args":[{"name":"index","external_name":"index","restriction":"Int32"}],"return_type":"Nil","visibility":"Public","body":"if includes?(index)\nelse\n  return\nend\ncase index\nwhen @start\n  @start = @succ[index]\nwhen .>(@start)\n  @succ[@pred[index]] = @succ[index]\n  @pred[@succ[index]] = @pred[index]\nelse\n  if index < @start\n    raise(IndexError.new)\n  end\nend\n@succ[index] = 0\n"}},{"html_id":"each(&:Int32->):Nil-instance-method","name":"each","doc":"Yields each index in the list.","summary":"<p>Yields each index in the list.</p>","abstract":false,"location":{"filename":"src/hclust/index_list.cr","line_number":32,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L32"},"def":{"name":"each","yields":1,"block_arg":{"name":"","external_name":"","restriction":"(Int32 ->)"},"return_type":"Nil","visibility":"Public","body":"index = @start\nwhile index < @size\n  yield index\n  index = @succ[index]\nend\n"}},{"html_id":"each(*,withinrange:Range(Int32?,Int32?),skip:Int32=0,&:Int32->):Nil-instance-method","name":"each","doc":"Yields each index in the list within the given range. It discards\n*skip* elements before yielding.","summary":"<p>Yields each index in the list within the given range.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"range","external_name":"within","restriction":"Range(Int32 | ::Nil, Int32 | ::Nil)"},{"name":"skip","default_value":"0","external_name":"skip","restriction":"Int32"}],"args_string":"(*, within range : Range(Int32?, Int32?), skip : Int32 = 0, & : Int32 -> ) : Nil","args_html":"(*, within range : Range(Int32?, Int32?), skip : Int32 = <span class=\"n\">0</span>, & : Int32 -> ) : Nil","location":{"filename":"src/hclust/index_list.cr","line_number":42,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L42"},"def":{"name":"each","args":[{"name":"","external_name":"","restriction":""},{"name":"range","external_name":"within","restriction":"Range(Int32 | ::Nil, Int32 | ::Nil)"},{"name":"skip","default_value":"0","external_name":"skip","restriction":"Int32"}],"splat_index":0,"yields":1,"block_arg":{"name":"","external_name":"","restriction":"(Int32 ->)"},"return_type":"Nil","visibility":"Public","body":"start = range.begin || @start\nstop = range.end || @size\nif range.end && (!range.exclusive?)\n  stop = stop + 1\nend\nstop = Math.min(stop, @size)\nif @start <= start && start < @size\nelse\n  raise(IndexError.new)\nend\nwhile !((start == stop) || (start.in?(self)))\n  start = start + 1\nend\nindex = start\nwhile index < stop\n  if skip > 0\n  else\n    yield index\n  end\n  index = @succ[index]\n  skip = skip - 1\nend\n"}},{"html_id":"each(*,omitindex:Int32,&:Int32->):Nil-instance-method","name":"each","doc":"Yields each index except *index*. Useful for iterating in pairs.","summary":"<p>Yields each index except <em>index</em>.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"index","external_name":"omit","restriction":"Int32"}],"args_string":"(*, omit index : Int32, & : Int32 -> ) : Nil","args_html":"(*, omit index : Int32, & : Int32 -> ) : Nil","location":{"filename":"src/hclust/index_list.cr","line_number":65,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L65"},"def":{"name":"each","args":[{"name":"","external_name":"","restriction":""},{"name":"index","external_name":"omit","restriction":"Int32"}],"splat_index":0,"yields":1,"block_arg":{"name":"","external_name":"","restriction":"(Int32 ->)"},"return_type":"Nil","visibility":"Public","body":"other = @start\nwhile other < index\n  yield other\n  other = @succ[other]\nend\nif other == index\n  other = @succ[index]\nend\nwhile other < @size\n  yield other\n  other = @succ[other]\nend\n"}},{"html_id":"first:Int32-instance-method","name":"first","doc":"Returns the first index. Raises `Enumerable::EmptyError` if the list\nis empty.","summary":"<p>Returns the first index.</p>","abstract":false,"location":{"filename":"src/hclust/index_list.cr","line_number":81,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L81"},"def":{"name":"first","return_type":"Int32","visibility":"Public","body":"first? || (raise(Enumerable::EmptyError.new))"}},{"html_id":"first?:Int32?-instance-method","name":"first?","doc":"Returns the first index or `nil` if the list is empty.","summary":"<p>Returns the first index or <code>nil</code> if the list is empty.</p>","abstract":false,"location":{"filename":"src/hclust/index_list.cr","line_number":86,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L86"},"def":{"name":"first?","return_type":"Int32 | ::Nil","visibility":"Public","body":"if @start < @size\n  @start\nend"}},{"html_id":"includes?(index:Int32):Bool-instance-method","name":"includes?","doc":"Returns `true` if the list includes the given index, else `false`.","summary":"<p>Returns <code>true</code> if the list includes the given index, else <code>false</code>.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int32"}],"args_string":"(index : Int32) : Bool","args_html":"(index : Int32) : Bool","location":{"filename":"src/hclust/index_list.cr","line_number":91,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L91"},"def":{"name":"includes?","args":[{"name":"index","external_name":"index","restriction":"Int32"}],"return_type":"Bool","visibility":"Public","body":"@succ[index] > 0"}},{"html_id":"nearest_to(index:Int32,dism:DistanceMatrix,&:Int32,Float64->Float64):Tuple(Int32,Float64)-instance-method","name":"nearest_to","doc":"Returns the nearest index to the given index based on the block's\nreturns value. Both the index and distance taken from the distance\nmatrix are yielded such that the block may compute a new distance if\nneeded.","summary":"<p>Returns the nearest index to the given index based on the block's returns value.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int32"},{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"}],"args_string":"(index : Int32, dism : DistanceMatrix, & : Int32, Float64 -> Float64) : Tuple(Int32, Float64)","args_html":"(index : Int32, dism : <a href=\"../HClust/DistanceMatrix.html\">DistanceMatrix</a>, & : Int32, Float64 -> Float64) : Tuple(Int32, Float64)","location":{"filename":"src/hclust/index_list.cr","line_number":137,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L137"},"def":{"name":"nearest_to","args":[{"name":"index","external_name":"index","restriction":"Int32"},{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"}],"yields":2,"block_arg":{"name":"","external_name":"","restriction":"(Int32, Float64 -> Float64)"},"return_type":"::Tuple(Int32, Float64)","visibility":"Public","body":"nearest_index = @start\nmin_dis = Float64::MAX\nother = @start\nwhile other < index\n  dis = dism.unsafe_fetch(other, index)\n  dis = yield other, dis\n  if dis < min_dis\n    nearest_index = other\n    min_dis = dis\n  end\n  other = @succ[other]\nend\nif other == index\n  other = @succ[index]\nend\nwhile other < @size\n  dis = dism.unsafe_fetch(index, other)\n  dis = yield other, dis\n  if dis < min_dis\n    nearest_index = other\n    min_dis = dis\n  end\n  other = @succ[other]\nend\n{nearest_index, min_dis}\n"}},{"html_id":"nearest_to(index:Int32,&:Int32->T):Tuple(Int32,T)forallT-instance-method","name":"nearest_to","doc":"Returns the nearest index to the given index based on the block's\nreturns value.","summary":"<p>Returns the nearest index to the given index based on the block's returns value.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int32"}],"args_string":"(index : Int32, & : Int32 -> T) : Tuple(Int32, T) forall T","args_html":"(index : Int32, & : Int32 -> T) : Tuple(Int32, T) forall T","location":{"filename":"src/hclust/index_list.cr","line_number":112,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L112"},"def":{"name":"nearest_to","args":[{"name":"index","external_name":"index","restriction":"Int32"}],"yields":1,"block_arg":{"name":"","external_name":"","restriction":"(Int32 -> T)"},"return_type":"::Tuple(Int32, T)","visibility":"Public","body":"nearest_index = @start\nmin_dis = T::MAX\neach(omit: index) do |other|\n  dis = yield other\n  if dis < min_dis\n    nearest_index = other\n    min_dis = dis\n  end\nend\n{nearest_index, min_dis}\n"}},{"html_id":"nearest_to(index:Int32,dism:DistanceMatrix):Tuple(Int32,Float64)-instance-method","name":"nearest_to","doc":"Returns the nearest index to the given index based on the distance\nmatrix.","summary":"<p>Returns the nearest index to the given index based on the distance matrix.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int32"},{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"}],"args_string":"(index : Int32, dism : DistanceMatrix) : Tuple(Int32, Float64)","args_html":"(index : Int32, dism : <a href=\"../HClust/DistanceMatrix.html\">DistanceMatrix</a>) : Tuple(Int32, Float64)","location":{"filename":"src/hclust/index_list.cr","line_number":128,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L128"},"def":{"name":"nearest_to","args":[{"name":"index","external_name":"index","restriction":"Int32"},{"name":"dism","external_name":"dism","restriction":"DistanceMatrix"}],"return_type":"::Tuple(Int32, Float64)","visibility":"Public","body":"nearest_to(index, dism) do |_, dis|\n  dis\nend"}},{"html_id":"size:Int32-instance-method","name":"size","doc":"Returns the total number of indexes in the list.","summary":"<p>Returns the total number of indexes in the list.</p>","abstract":false,"location":{"filename":"src/hclust/index_list.cr","line_number":171,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L171"},"def":{"name":"size","return_type":"Int32","visibility":"Public","body":"@size"}},{"html_id":"to_a:Array(Int32)-instance-method","name":"to_a","doc":"Returns an `Array` with all the indexes in the list.","summary":"<p>Returns an <code>Array</code> with all the indexes in the list.</p>","abstract":false,"location":{"filename":"src/hclust/index_list.cr","line_number":176,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L176"},"def":{"name":"to_a","return_type":"Array(Int32)","visibility":"Public","body":"nodes = [] of Int32\neach do |node|\n  nodes << node\nend\nnodes\n"}},{"html_id":"unsafe_succ(index):Int32-instance-method","name":"unsafe_succ","doc":"Returns the succeeding index to `index`, without doing any bounds\ncheck.","summary":"<p>Returns the succeeding index to <code>index</code>, without doing any bounds check.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":""}],"args_string":"(index) : Int32","args_html":"(index) : Int32","location":{"filename":"src/hclust/index_list.cr","line_number":187,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/index_list.cr#L187"},"def":{"name":"unsafe_succ","args":[{"name":"index","external_name":"index","restriction":""}],"return_type":"Int32","visibility":"Public","body":"@succ[index]"}}]},{"html_id":"hclust/HClust/IndexPriorityQueue","path":"HClust/IndexPriorityQueue.html","kind":"class","full_name":"HClust::IndexPriorityQueue","name":"IndexPriorityQueue","abstract":false,"superclass":{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"hclust/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/hclust/queue.cr","line_number":14,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L14"}],"repository_name":"hclust","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"hclust/HClust","kind":"module","full_name":"HClust","name":"HClust"},"doc":"An `IndexPriorityQueue` is a priority queue of contiguous zero-based\nindexes.\n\nIt supports efficient access to and removal of the element with\nhighest priority (defined as the smallest value). It is designed for\noptimally searching nearest neighbors (priority = dissimilarity).\n\nIt is implemented as a min binary heap (where the top is the minimum\nelement), where the indexes and priorities are also stored separately.\nNote that deleted indexes are marked as inactive, but otherwise kept\nin memory. Therefore, indexing is not supported.","summary":"<p>An <code><a href=\"../HClust/IndexPriorityQueue.html\">IndexPriorityQueue</a></code> is a priority queue of contiguous zero-based indexes.</p>","constructors":[{"html_id":"new(size:Int32,&)-class-method","name":"new","doc":"Creates a new `IndexPriorityQueue` with indexes in the range `[0,\nsize)`, invoking the given block for each index and setting its\npriority to the block's return value.","summary":"<p>Creates a new <code><a href=\"../HClust/IndexPriorityQueue.html\">IndexPriorityQueue</a></code> with indexes in the range <code>[0, size)</code>, invoking the given block for each index and setting its priority to the block's return value.</p>","abstract":false,"args":[{"name":"size","external_name":"size","restriction":"Int32"}],"args_string":"(size : Int32, &)","args_html":"(size : Int32, &)","location":{"filename":"src/hclust/queue.cr","line_number":21,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L21"},"def":{"name":"new","args":[{"name":"size","external_name":"size","restriction":"Int32"}],"yields":1,"visibility":"Public","body":"_ = allocate\n_.initialize(size) do |_arg0|\n  yield _arg0\nend\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"html_id":"new(priorities:Array(Number)):self-class-method","name":"new","doc":"Creates a new `IndexPriorityQueue` from the given priorities with\nindexes in the range `[0, priorities.size)`.","summary":"<p>Creates a new <code><a href=\"../HClust/IndexPriorityQueue.html\">IndexPriorityQueue</a></code> from the given priorities with indexes in the range <code>[0, priorities.size)</code>.</p>","abstract":false,"args":[{"name":"priorities","external_name":"priorities","restriction":"Array(Number)"}],"args_string":"(priorities : Array(Number)) : self","args_html":"(priorities : Array(Number)) : <span class=\"k\">self</span>","location":{"filename":"src/hclust/queue.cr","line_number":42,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L42"},"def":{"name":"new","args":[{"name":"priorities","external_name":"priorities","restriction":"Array(Number)"}],"return_type":"self","visibility":"Public","body":"IndexPriorityQueue.new(priorities.size) do |i|\n  (priorities.unsafe_fetch(i)).to_f\nend"}}],"instance_methods":[{"html_id":"empty?:Bool-instance-method","name":"empty?","doc":"Returns `true` if the queue is empty, else `false`.","summary":"<p>Returns <code>true</code> if the queue is empty, else <code>false</code>.</p>","abstract":false,"location":{"filename":"src/hclust/queue.cr","line_number":58,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L58"},"def":{"name":"empty?","return_type":"Bool","visibility":"Public","body":"@size == 0"}},{"html_id":"first:Int32-instance-method","name":"first","doc":"Returns the index with highest priority (smallest value). Raises\n`Enumerable::EmptyError` if the list is empty.","summary":"<p>Returns the index with highest priority (smallest value).</p>","abstract":false,"location":{"filename":"src/hclust/queue.cr","line_number":64,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L64"},"def":{"name":"first","return_type":"Int32","visibility":"Public","body":"first? || (raise(Enumerable::EmptyError.new))"}},{"html_id":"first?:Int32?-instance-method","name":"first?","doc":"Returns the index with highest priority (smallest value), or `nil`\nif the queue is empty.","summary":"<p>Returns the index with highest priority (smallest value), or <code>nil</code> if the queue is empty.</p>","abstract":false,"location":{"filename":"src/hclust/queue.cr","line_number":70,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L70"},"def":{"name":"first?","return_type":"Int32 | ::Nil","visibility":"Public","body":"if empty?\nelse\n  @heap[0]\nend"}},{"html_id":"pop:Int32?-instance-method","name":"pop","doc":"Removes and returns the index with highest priority (smallest\nvalue), or `nil` if the queue is empty.\n\nNOTE: The queue is updated internally to restore the heap property.","summary":"<p>Removes and returns the index with highest priority (smallest value), or <code>nil</code> if the queue is empty.</p>","abstract":false,"location":{"filename":"src/hclust/queue.cr","line_number":113,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L113"},"def":{"name":"pop","return_type":"Int32 | ::Nil","visibility":"Public","body":"if empty?\n  return\nend\nif @size >= 2\n  swap(@heap[0], @heap[@size - 1])\nend\nlast = @heap[@size - 1]\n((@heap + @size) - 1).clear\n@size = @size - 1\n@mask.unsafe_put(last, false)\nif @size >= 2\n  heapify_down(@heap[0])\nend\nlast\n"}},{"html_id":"priority_at(index:Int32):Float64-instance-method","name":"priority_at","doc":"Returns the priority of the element at *index*. Raises `IndexError`\nif *index* is out of bounds or inactive (removed).","summary":"<p>Returns the priority of the element at <em>index</em>.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int32"}],"args_string":"(index : Int32) : Float64","args_html":"(index : Int32) : Float64","location":{"filename":"src/hclust/queue.cr","line_number":104,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L104"},"def":{"name":"priority_at","args":[{"name":"index","external_name":"index","restriction":"Int32"}],"return_type":"Float64","visibility":"Public","body":"if @mask[index]?\nelse\n  raise(IndexError.new)\nend\n@priorities[index]\n"}},{"html_id":"set_priority_at(index:Int,priority:Float64):Nil-instance-method","name":"set_priority_at","doc":"Updates the priority of the element at *index* with the given value.\n\nNOTE: The queue is updated internally to restore the heap property.","summary":"<p>Updates the priority of the element at <em>index</em> with the given value.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int"},{"name":"priority","external_name":"priority","restriction":"Float64"}],"args_string":"(index : Int, priority : Float64) : Nil","args_html":"(index : Int, priority : Float64) : Nil","location":{"filename":"src/hclust/queue.cr","line_number":131,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L131"},"def":{"name":"set_priority_at","args":[{"name":"index","external_name":"index","restriction":"Int"},{"name":"priority","external_name":"priority","restriction":"Float64"}],"return_type":"Nil","visibility":"Public","body":"if @mask[index]?\nelse\n  raise(IndexError.new)\nend\nold_priority = @priorities[index]\n@priorities[index] = priority\npriority < old_priority ? heapify_up(index) : heapify_down(index)\n"}},{"html_id":"size:Int32-instance-method","name":"size","doc":"Returns the number of indexes in the queue.","summary":"<p>Returns the number of indexes in the queue.</p>","abstract":false,"location":{"filename":"src/hclust/queue.cr","line_number":16,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L16"},"def":{"name":"size","return_type":"Int32","visibility":"Public","body":"@size"}},{"html_id":"to_a:Array(Int32)-instance-method","name":"to_a","doc":"Returns the indexes as an array.","summary":"<p>Returns the indexes as an array.</p>","abstract":false,"location":{"filename":"src/hclust/queue.cr","line_number":145,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/queue.cr#L145"},"def":{"name":"to_a","return_type":"Array(Int32)","visibility":"Public","body":"Array(Int32).new.tap do |arr|\n  @mask.each_with_index do |flag, i|\n    if flag\n      arr << i\n    end\n  end\nend"}}]},{"html_id":"hclust/HClust/Rule","path":"HClust/Rule.html","kind":"enum","full_name":"HClust::Rule","name":"Rule","abstract":false,"ancestors":[{"html_id":"hclust/Enum","kind":"struct","full_name":"Enum","name":"Enum"},{"html_id":"hclust/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"hclust/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"hclust/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/hclust/rule.cr","line_number":17,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L17"}],"repository_name":"hclust","program":false,"enum":true,"alias":false,"const":false,"constants":[{"id":"Average","name":"Average","value":"0","doc":"Defines the distance between the cluster *I ∪ J* and cluster *K* as\nthe arithmetic mean of all distances from every cluster *i ∈ I* and\n*j ∈ J* to *k ∈ K*:\n\n    d(I ∪ J) = (|I| * d(I, K) + |J| * d(J, K)) / (|I| + |J|)\n\nThis is also called the [UPGMA](https://en.wikipedia.org/wiki/UPGMA)\nmethod.","summary":"<p>Defines the distance between the cluster <em>I ∪ J</em> and cluster <em>K</em> as the arithmetic mean of all distances from every cluster <em>i ∈ I</em> and <em>j ∈ J</em> to <em>k ∈ K</em>:</p>"},{"id":"Centroid","name":"Centroid","value":"1","doc":"Defines the distance between the cluster *I ∪ J* and cluster *K* as\nthe distance between the cluster centroids or means:\n\n    d(I ∪ J) = sqrt((|I| * d(I, K)² + |J| * d(J, K))²) / (|I| + |J|)\n                    - (|I| * |J| * d(I, J)²) / (|I| + |J|)²)\n\nThis is also called the UPGMC method.\n\nWARNING: This method requires that the initial cluster distances are\n(proportional to) squared Euclidean distance.","summary":"<p>Defines the distance between the cluster <em>I ∪ J</em> and cluster <em>K</em> as the distance between the cluster centroids or means:</p>"},{"id":"Complete","name":"Complete","value":"2","doc":"Defines the distance between the cluster *I ∪ J* and cluster *K* as\nthe largest distance from every cluster *i ∈ I* and *j ∈ J* to *k ∈\nK*:\n\n    d(I ∪ J) = max(d(I, K), d(J, K))\n\nThis is also called the [farthest\nneighbor](https://en.wikipedia.org/wiki/Complete-linkage_clustering)\nmethod.","summary":"<p>Defines the distance between the cluster <em>I ∪ J</em> and cluster <em>K</em> as the largest distance from every cluster <em>i ∈ I</em> and <em>j ∈ J</em> to <em>k ∈ K</em>:</p>"},{"id":"Median","name":"Median","value":"3","doc":"Defines the distance between the cluster *I ∪ J* and cluster *K* as\nthe distance between the cluster centroids or means, where the\ncentroid of *I ∪ J* is simply defined as the average of the\ncentroids of *I* and *J*:\n\n    d(I ∪ J) = sqrt((d(I, K) + d(J, K)) / 2 - d(I, J) / 4)\n\nThis is also called the WPGMC method.\n\nWARNING: This method requires that the initial cluster distances\nmust be (proportional to) squared Euclidean distance.","summary":"<p>Defines the distance between the cluster <em>I ∪ J</em> and cluster <em>K</em> as the distance between the cluster centroids or means, where the centroid of <em>I ∪ J</em> is simply defined as the average of the centroids of <em>I</em> and <em>J</em>:</p>"},{"id":"Single","name":"Single","value":"4","doc":"Defines the distance between the cluster *I ∪ J* and cluster *K* as\nthe smallest distance from every cluster *i ∈ I* and *j ∈ J* to *k ∈\nK*:\n\n    d(I ∪ J) = max(d(I, K), d(J, K))\n\nThis is also called the [nearest\nneighbor](https://en.wikipedia.org/wiki/Single-linkage_clustering)\nmethod.","summary":"<p>Defines the distance between the cluster <em>I ∪ J</em> and cluster <em>K</em> as the smallest distance from every cluster <em>i ∈ I</em> and <em>j ∈ J</em> to <em>k ∈ K</em>:</p>"},{"id":"Ward","name":"Ward","value":"5","doc":"[Ward's minimum variance\ncriterion](https://en.wikipedia.org/wiki/Ward%27s_method) minimizes\nthe total intra-cluster variance. It defines the distance between\nthe cluster *I ∪ J* and cluster *K* as the weighted squared distance\nbetween cluster centers. Using the Lance–Williams formula, the\ndistance can be expressed as\n\n    d(I ∪ J) = sqrt((|I| + |K|) * d(I, K)²\n                    + (|J| + |K|) * d(J, K)²\n                    - |K| * d(I, J)²)\n\nWARNING: This method requires that the initial cluster distances are\n(proportional to) squared Euclidean distance.","summary":"<p><a href=\"https://en.wikipedia.org/wiki/Ward%27s_method\">Ward's minimum variance criterion</a> minimizes the total intra-cluster variance.</p>"},{"id":"Weighted","name":"Weighted","value":"6","doc":"Defines the distance between the cluster *I ∪ J* and cluster *K* as\nthe arithmetic mean of the average distances between clusters *I*\nand *K* (*d(I, K)*) and clusters *J* and *K* (*d(J, K)*):\n\n    d(I ∪ J) = (da(I, K) + da(J, K)) / 2\n\nwhere *da(X, Y)* means the average distance between *X* and *Y*.\nThis is also called the [WPGMA](https://en.wikipedia.org/wiki/WPGMA)\nmethod.","summary":"<p>Defines the distance between the cluster <em>I ∪ J</em> and cluster <em>K</em> as the arithmetic mean of the average distances between clusters <em>I</em> and <em>K</em> (<em>d(I, K)</em>) and clusters <em>J</em> and <em>K</em> (<em>d(J, K)</em>):</p>"}],"namespace":{"html_id":"hclust/HClust","kind":"module","full_name":"HClust","name":"HClust"},"doc":"An enum that provides linkage rules that dictate how the distances\nshould be updated upon merging two clusters.\n\nA linkage rule is used when computing the distances of a newly formed\ncluster *I ∪ J* by the union of clusters *I* and *J* and every other\nexisting cluster *K* (*d(*I ∪ J*, K)*) during the clustering\nprocedure. Note that *d(X, Y)* expands to all distances between the\nclusters *x ∈ X* and *y ∈ Y* (*d(x, y)*).\n\nThe update formula for each linkage rule is provided as a class method\nwith the same name, e.g., `Rule.single` for the single linkage rule.\nThe method accepts the pre-computed distances *d(I, J)*, *d(I, K)*,\nand *d(J, K)*, and cluster sizes (|*I*|, |*J*|, and |*K*|). This is an\nin-place method, where the distance to be updated (tipically, *d(J,\nK)* as cluster *J* is reused as the new cluster) is passed as a\npointer to the corresponding position in the distance matrix.","summary":"<p>An enum that provides linkage rules that dictate how the distances should be updated upon merging two clusters.</p>","class_methods":[{"html_id":"average(d_ij:Float64,d_ik:Float64,ptr_jk:Pointer(Float64),n_i:Int32,n_j:Int32,n_k:Int32):Nil-class-method","name":"average","doc":"Update formula for the average linkage rule. The distance is\ncomputed between the newly formed cluster *I ∪ J* and *K* from the\npre-computed distances between the clusters *I*, *J*, and *K*, and\ncluster sizes.\n\nNOTE: The value at *ptr_jk* will be modified according to the\nlinkage rule.","summary":"<p>Update formula for the average linkage rule.</p>","abstract":false,"args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"args_string":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","args_html":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","location":{"filename":"src/hclust/rule.cr","line_number":109,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L109"},"def":{"name":"average","args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"return_type":"Nil","visibility":"Public","body":"ptr_jk.value = ((n_i * d_ik) + (n_j * ptr_jk.value)) / (n_i + n_j)"}},{"html_id":"centroid(d_ij:Float64,d_ik:Float64,ptr_jk:Pointer(Float64),n_i:Int32,n_j:Int32,n_k:Int32):Nil-class-method","name":"centroid","doc":"Update formula for the centroid linkage rule. The distance is\ncomputed between the newly formed cluster *I ∪ J* and *K* from the\npre-computed distances between the clusters *I*, *J*, and *K*, and\ncluster sizes.\n\nNOTE: The value at *ptr_jk* will be modified according to the\nlinkage rule.","summary":"<p>Update formula for the centroid linkage rule.</p>","abstract":false,"args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"args_string":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","args_html":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","location":{"filename":"src/hclust/rule.cr","line_number":124,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L124"},"def":{"name":"centroid","args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"return_type":"Nil","visibility":"Public","body":"n_ij = n_i + n_j\nptr_jk.value = (((n_i * d_ik) + (n_j * ptr_jk.value)) / n_ij) - (((n_i * n_j) * d_ij) / (n_ij ** 2))\n"}},{"html_id":"complete(d_ij:Float64,d_ik:Float64,ptr_jk:Pointer(Float64),n_i:Int32,n_j:Int32,n_k:Int32):Nil-class-method","name":"complete","doc":"Update formula for the complete linkage rule. The distance is\ncomputed between the newly formed cluster *I ∪ J* and *K* from the\npre-computed distances between the clusters *I*, *J*, and *K*, and\ncluster sizes.\n\nNOTE: The value at *ptr_jk* will be modified according to the\nlinkage rule.","summary":"<p>Update formula for the complete linkage rule.</p>","abstract":false,"args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"args_string":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","args_html":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","location":{"filename":"src/hclust/rule.cr","line_number":141,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L141"},"def":{"name":"complete","args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"return_type":"Nil","visibility":"Public","body":"if d_ik > ptr_jk.value\n  ptr_jk.value = d_ik\nend"}},{"html_id":"median(d_ij:Float64,d_ik:Float64,ptr_jk:Pointer(Float64),n_i:Int32,n_j:Int32,n_k:Int32):Nil-class-method","name":"median","doc":"Update formula for the median linkage rule. The distance is\ncomputed between the newly formed cluster *I ∪ J* and *K* from the\npre-computed distances between the clusters *I*, *J*, and *K*, and\ncluster sizes.\n\nNOTE: The value at *ptr_jk* will be modified according to the\nlinkage rule.","summary":"<p>Update formula for the median linkage rule.</p>","abstract":false,"args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"args_string":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","args_html":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","location":{"filename":"src/hclust/rule.cr","line_number":156,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L156"},"def":{"name":"median","args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"return_type":"Nil","visibility":"Public","body":"ptr_jk.value = ((d_ik + ptr_jk.value) * 0.5) - (d_ij * 0.25)"}},{"html_id":"single(d_ij:Float64,d_ik:Float64,ptr_jk:Pointer(Float64),n_i:Int32,n_j:Int32,n_k:Int32):Nil-class-method","name":"single","doc":"Update formula for the single linkage rule. The distance is\ncomputed between the newly formed cluster *I ∪ J* and *K* from the\npre-computed distances between the clusters *I*, *J*, and *K*, and\ncluster sizes.\n\nNOTE: The value at *ptr_jk* will be modified according to the\nlinkage rule.","summary":"<p>Update formula for the single linkage rule.</p>","abstract":false,"args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"args_string":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","args_html":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","location":{"filename":"src/hclust/rule.cr","line_number":171,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L171"},"def":{"name":"single","args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"return_type":"Nil","visibility":"Public","body":"if d_ik < ptr_jk.value\n  ptr_jk.value = d_ik\nend"}},{"html_id":"ward(d_ij:Float64,d_ik:Float64,ptr_jk:Pointer(Float64),n_i:Int32,n_j:Int32,n_k:Int32):Nil-class-method","name":"ward","doc":"Update formula for the ward linkage rule. The distance is\ncomputed between the newly formed cluster *I ∪ J* and *K* from the\npre-computed distances between the clusters *I*, *J*, and *K*, and\ncluster sizes.\n\nNOTE: The value at *ptr_jk* will be modified according to the\nlinkage rule.","summary":"<p>Update formula for the ward linkage rule.</p>","abstract":false,"args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"args_string":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","args_html":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","location":{"filename":"src/hclust/rule.cr","line_number":186,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L186"},"def":{"name":"ward","args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"return_type":"Nil","visibility":"Public","body":"ptr_jk.value = ((((n_i + n_k) * d_ik) + ((n_j + n_k) * ptr_jk.value)) - (n_k * d_ij)) / ((n_i + n_j) + n_k)"}},{"html_id":"weighted(d_ij:Float64,d_ik:Float64,ptr_jk:Pointer(Float64),n_i:Int32,n_j:Int32,n_k:Int32):Nil-class-method","name":"weighted","doc":"Update formula for the weighted linkage rule. The distance is\ncomputed between the newly formed cluster *I ∪ J* and *K* from the\npre-computed distances between the clusters *I*, *J*, and *K*, and\ncluster sizes.\n\nNOTE: The value at *ptr_jk* will be modified according to the\nlinkage rule.","summary":"<p>Update formula for the weighted linkage rule.</p>","abstract":false,"args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"args_string":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","args_html":"(d_ij : Float64, d_ik : Float64, ptr_jk : Pointer(Float64), n_i : Int32, n_j : Int32, n_k : Int32) : Nil","location":{"filename":"src/hclust/rule.cr","line_number":204,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L204"},"def":{"name":"weighted","args":[{"name":"d_ij","external_name":"d_ij","restriction":"Float64"},{"name":"d_ik","external_name":"d_ik","restriction":"Float64"},{"name":"ptr_jk","external_name":"ptr_jk","restriction":"Pointer(Float64)"},{"name":"n_i","external_name":"n_i","restriction":"Int32"},{"name":"n_j","external_name":"n_j","restriction":"Int32"},{"name":"n_k","external_name":"n_k","restriction":"Int32"}],"return_type":"Nil","visibility":"Public","body":"ptr_jk.value = (d_ik + ptr_jk.value) * 0.5"}}],"instance_methods":[{"html_id":"average?-instance-method","name":"average?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":26,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L26"},"def":{"name":"average?","visibility":"Public","body":"self == Average"}},{"html_id":"centroid?-instance-method","name":"centroid?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":38,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L38"},"def":{"name":"centroid?","visibility":"Public","body":"self == Centroid"}},{"html_id":"complete?-instance-method","name":"complete?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":49,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L49"},"def":{"name":"complete?","visibility":"Public","body":"self == Complete"}},{"html_id":"median?-instance-method","name":"median?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":62,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L62"},"def":{"name":"median?","visibility":"Public","body":"self == Median"}},{"html_id":"needs_squared_euclidean?:Bool-instance-method","name":"needs_squared_euclidean?","doc":"Returns `true` if the linkage rule requires that the initial\ncluster distances are (proportional to) squared Euclidean\ndistance, else `false`.","summary":"<p>Returns <code>true</code> if the linkage rule requires that the initial cluster distances are (proportional to) squared Euclidean distance, else <code>false</code>.</p>","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":214,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L214"},"def":{"name":"needs_squared_euclidean?","return_type":"Bool","visibility":"Public","body":"case self\nwhen .centroid?, .median?, .ward?\n  true\nelse\n  false\nend"}},{"html_id":"order_dependent?:Bool-instance-method","name":"order_dependent?","doc":"Returns `true` if the distance formula depends on the order\nwhich the clusters were formed by merging, else `false`.\n\nThis is used in the cluster relabeling after linkage. See\n`Dendrogram#relabel`.","summary":"<p>Returns <code>true</code> if the distance formula depends on the order which the clusters were formed by merging, else <code>false</code>.</p>","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":228,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L228"},"def":{"name":"order_dependent?","return_type":"Bool","visibility":"Public","body":"case self\nwhen .centroid?, .median?\n  true\nelse\n  false\nend"}},{"html_id":"single?-instance-method","name":"single?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":73,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L73"},"def":{"name":"single?","visibility":"Public","body":"self == Single"}},{"html_id":"ward?-instance-method","name":"ward?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":88,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L88"},"def":{"name":"ward?","visibility":"Public","body":"self == Ward"}},{"html_id":"weighted?-instance-method","name":"weighted?","abstract":false,"location":{"filename":"src/hclust/rule.cr","line_number":99,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/rule.cr#L99"},"def":{"name":"weighted?","visibility":"Public","body":"self == Weighted"}}]},{"html_id":"hclust/HClust/UnionFind","path":"HClust/UnionFind.html","kind":"class","full_name":"HClust::UnionFind","name":"UnionFind","abstract":false,"superclass":{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"hclust/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"hclust/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/hclust/union_find.cr","line_number":13,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/union_find.cr#L13"}],"repository_name":"hclust","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"hclust/HClust","kind":"module","full_name":"HClust","name":"HClust"},"doc":"A `UnionFind` is a data structure that stores a partition of a set\ninto disjoint subsets encoded as contiguous zero-based indexes.\n\nThis is a specialized implementation of a union–find data structure\nfor linkage, where subsets correspond to cluster labels. It supports\nefficient lookups and frequent unions.\n\nInternally, it is implemented as an array of size `N + N - 1` such\nthat each element points to the enclosing cluster label of the\ncorresponding cluster. Disjoint clusters (root) are labeled with 0.\nLabels of the newly created clusters follows the SciPy convention,\nwhere new labels start at N.","summary":"<p>A <code><a href=\"../HClust/UnionFind.html\">UnionFind</a></code> is a data structure that stores a partition of a set into disjoint subsets encoded as contiguous zero-based indexes.</p>","constructors":[{"html_id":"new(size:Int32)-class-method","name":"new","doc":"Creates a new `UnionFind` with the cluster labels in the range `[0,\nsize * size - 1)`.","summary":"<p>Creates a new <code><a href=\"../HClust/UnionFind.html\">UnionFind</a></code> with the cluster labels in the range <code>[0, size * size - 1)</code>.</p>","abstract":false,"args":[{"name":"size","external_name":"size","restriction":"Int32"}],"args_string":"(size : Int32)","args_html":"(size : Int32)","location":{"filename":"src/hclust/union_find.cr","line_number":16,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/union_find.cr#L16"},"def":{"name":"new","args":[{"name":"size","external_name":"size","restriction":"Int32"}],"visibility":"Public","body":"_ = allocate\n_.initialize(size)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"html_id":"find(index:Int):Int32?-instance-method","name":"find","doc":"Returns the root cluster for the given cluster label, or `nil` if\nout of bounds.\n\nIteratively goes through all parent elements until a root (parent =\n0) is found. To make subsequent lookups faster, the label for the\ngiven cluster and all its parents is updated with the found root\nelement.","summary":"<p>Returns the root cluster for the given cluster label, or <code>nil</code> if out of bounds.</p>","abstract":false,"args":[{"name":"index","external_name":"index","restriction":"Int"}],"args_string":"(index : Int) : Int32?","args_html":"(index : Int) : Int32?","location":{"filename":"src/hclust/union_find.cr","line_number":32,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/union_find.cr#L32"},"def":{"name":"find","args":[{"name":"index","external_name":"index","restriction":"Int"}],"return_type":"Int32 | ::Nil","visibility":"Public","body":"if 0 <= index && index < @next_parent\nelse\n  return\nend\nparent = index\nwhile !(p = @parents[parent]).zero?\n  parent = p\nend\nwhile !(p = @parents[index]).zero?\n  @parents[index] = parent\n  index = p\nend\nparent\n"}},{"html_id":"union(i:Int,j:Int):Int32?-instance-method","name":"union","doc":"Joins two clusters with the given labels and returns the label of\nthe newly created cluster, or `nil` if the two clusters are already\njoined. Raises `IndexError` if either *i* or *j* is out of bounds.\n\nIf the two clusters belongs to the same parent cluster, this method\ndoes nothing.","summary":"<p>Joins two clusters with the given labels and returns the label of the newly created cluster, or <code>nil</code> if the two clusters are already joined.</p>","abstract":false,"args":[{"name":"i","external_name":"i","restriction":"Int"},{"name":"j","external_name":"j","restriction":"Int"}],"args_string":"(i : Int, j : Int) : Int32?","args_html":"(i : Int, j : Int) : Int32?","location":{"filename":"src/hclust/union_find.cr","line_number":54,"url":"https://github.com/franciscoadasme/hclust/blob/1865f363f0747194ca1f6021e87460e222fd9d83/src/hclust/union_find.cr#L54"},"def":{"name":"union","args":[{"name":"i","external_name":"i","restriction":"Int"},{"name":"j","external_name":"j","restriction":"Int"}],"return_type":"Int32 | ::Nil","visibility":"Public","body":"if i < @next_parent && j < @next_parent\nelse\n  raise(IndexError.new)\nend\nif (find(i)) == (find(j))\n  return\nend\nif @next_parent < @parents.size\nelse\n  raise(\"BUG: unreachable\")\nend\n@parents[i] = @parents[j] = @next_parent\n@next_parent = @next_parent + 1\n@parents[i]\n"}}]}]}]}})