<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 1.3.2">
<meta name="crystal_docs.project_version" content="main">
<meta name="crystal_docs.project_name" content="hclust">



<link href="css/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="js/doc.js"></script>

  <meta name="repository-name" content="hclust">
  <title>HClust - hclust main</title>
  <script type="text/javascript">
    CrystalDocs.base_path = "";
  </script>
</head>
<body>

<svg class="hidden">
  <symbol id="octicon-link" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
  </symbol>
</svg>
<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="project-summary">
      <h1 class="project-name">
        <a href="index.html">
          hclust
        </a>
      </h1>

      <span class="project-version">
        main
      </span>
    </div>
  </div>

  <div class="search-results hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class="parent open current" data-id="hclust/HClust" data-name="hclust">
      <a href="HClust.html">HClust</a>
      
        <ul>
  
  <li class=" " data-id="hclust/HClust/ChainRule" data-name="hclust::chainrule">
      <a href="HClust/ChainRule.html">ChainRule</a>
      
    </li>
  
  <li class="parent " data-id="hclust/HClust/Dendrogram" data-name="hclust::dendrogram">
      <a href="HClust/Dendrogram.html">Dendrogram</a>
      
        <ul>
  
  <li class=" " data-id="hclust/HClust/Dendrogram/Step" data-name="hclust::dendrogram::step">
      <a href="HClust/Dendrogram/Step.html">Step</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="hclust/HClust/DistanceMatrix" data-name="hclust::distancematrix">
      <a href="HClust/DistanceMatrix.html">DistanceMatrix</a>
      
    </li>
  
  <li class=" " data-id="hclust/HClust/IndexList" data-name="hclust::indexlist">
      <a href="HClust/IndexList.html">IndexList</a>
      
    </li>
  
  <li class=" " data-id="hclust/HClust/IndexPriorityQueue" data-name="hclust::indexpriorityqueue">
      <a href="HClust/IndexPriorityQueue.html">IndexPriorityQueue</a>
      
    </li>
  
  <li class=" " data-id="hclust/HClust/Rule" data-name="hclust::rule">
      <a href="HClust/Rule.html">Rule</a>
      
    </li>
  
  <li class=" " data-id="hclust/HClust/UnionFind" data-name="hclust::unionfind">
      <a href="HClust/UnionFind.html">UnionFind</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<h1 class="type-name">

  <span class="kind">module</span> HClust

</h1>





  <h2>
    <a id="overview" class="anchor" href="#overview">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>
    Overview
  </h2>

  <p>The <code><a href="HClust.html">HClust</a></code> module provides methods for fast hierarchical
agglomerative clustering featuring efficient linkage algorithms.</p>
<p>Cluster analysis or <a href="https://en.wikipedia.org/wiki/Cluster_analysis">clustering</a> arrange a set of objects into
distinct groups or clusters such that the elements within a cluster
are more similar to each other than those in other clusters based on a
given criterion. The latter is defined as a measure of dissimilarity
between the objects, and it's usually encoded in a <code><a href="HClust/DistanceMatrix.html">DistanceMatrix</a></code>.
Hierarchical agglomerative clustering builds a hierarchy of clusters,
where each object or element starts in its own cluster, and then they
are progressively merged forming a hierarchy among them. The
dissimilarities bewteen a newly-created cluster and all other clusters
are updated after each merging step. The dissimilarity between two
clusters is dictated by the chosen linkage criterion or rule. The
obtained hierarchy is often encoded as a <code><a href="HClust/Dendrogram.html">Dendrogram</a></code>, which can be
cut at a given dissimilarity value to obtain flat clusters such that
the elements of a flat cluster have a cophenetic distance no greater
than the given value (see <code><a href="HClust/Dendrogram.html#flatten%28height%3ANumber%29%3AArray%28Array%28Int32%29%29-instance-method">Dendrogram#flatten</a></code>).</p>
<p>The standard algorithm has a time complexity of Θ(<em>N</em>³), which is
implemented by the <code><a href="HClust.html#primitive%28dism%3ADistanceMatrix%2Crule%3ARule%29%3ADendrogram-class-method">.primitive</a></code> method. However, optimal algorithms
are provided based on the work of Daniel Müllner [<a href="https://arxiv.org/abs/1109.2378">1</a>], which
describes several optimizations over the standard algorithm
(implemented by the <code><a href="HClust.html#generic%28dism%3ADistanceMatrix%2Crule%3ARule%29%3ADendrogram-class-method">.generic</a></code> method), and fast methods for special
cases such as the minimum spanning tree (MST) method (<code><a href="HClust.html#mst%28dism%3ADistanceMatrix%29%3ADendrogram-class-method">.mst</a></code>) for
single linkage and nearest-neighbor-chain (NN-chain) method
(<code><a href="HClust.html#nn_chain%28dism%3ADistanceMatrix%2Crule%3AChainRule%29%3ADendrogram-class-method">.nn_chain</a></code>) for average, complete, Ward's, and weighted linkage.
Thus, the best-case complexity can be reduced to Θ(<em>N</em>²), where, in
practice, the runtime of the general case is close to this.</p>
<p>The current implementation is heavily based on Müllner's own
implementation found in the <a href="https://github.com/dmuellner/fastcluster">fastcluster</a> C++ library, and parts of
the implementation were also inspired by the <a href="https://github.com/diffeo/kodama">kodama</a> Rust crate (code
for updating distances) and <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.fcluster.html">SciPy</a> Python library (code for
generating flat clusters).</p>
<p>The most relevant types and methods for practical usage are the
following:</p>
<ul>
<li><code><a href="HClust.html#cluster%28elements%3AIndexable%28T%29%2Ccutoff%3ANumber%2Crule%3ARule%3D%3Asingle%2C%26%3AT%2CT-%3EFloat64%29%3AArray%28Array%28T%29%29forallT-class-method">.cluster</a></code> performs hierarchical clustering of a set of elements
using the pairwise dissimilarities returned by the given block.</li>
<li><code><a href="HClust.html#linkage%28dism%3ADistanceMatrix%2Crule%3ARule%2Creuse%3ABool%3Dfalse%29%3ADendrogram-class-method">.linkage</a></code> performs hierarchical clustering based on a pairwise
<code><a href="HClust/DistanceMatrix.html">DistanceMatrix</a></code> returning a <code><a href="HClust/Dendrogram.html">Dendrogram</a></code> as output.</li>
<li><code><a href="HClust/Rule.html">Rule</a></code> is an enum that determines the linkage criterion or rule.</li>
<li><code><a href="HClust/Dendrogram.html">Dendrogram</a></code> represents a step-wise dendrogram that encodes the
hierarchy of clusters obtained from hierarchical clustering.</li>
<li><code><a href="HClust/Dendrogram.html#flatten%28height%3ANumber%29%3AArray%28Array%28Int32%29%29-instance-method">Dendrogram#flatten</a></code> returns a list of flat clusters.</li>
</ul>
<p>The available linkage rules are:</p>
<ul>
<li><code><a href="HClust/Rule.html#Average">Rule::Average</a></code> or UPGMA method.</li>
<li><code><a href="HClust/Rule.html#Centroid">Rule::Centroid</a></code> or UPGMC method.</li>
<li><code><a href="HClust/Rule.html#Complete">Rule::Complete</a></code> or farthest neighbor method.</li>
<li><code><a href="HClust/Rule.html#Median">Rule::Median</a></code> or WPGMC method.</li>
<li><code><a href="HClust/Rule.html#Single">Rule::Single</a></code> or nearest neighbor method.</li>
<li><code><a href="HClust/Rule.html#Ward">Rule::Ward</a></code>'s minimum variance method</li>
<li><code><a href="HClust/Rule.html#Weighted">Rule::Weighted</a></code> or WPGMA method.</li>
</ul>
<p>See <code><a href="HClust/Rule.html">Rule</a></code> documentation for details.</p>
<h3><a id="clustering-example" class="anchor" href="#clustering-example">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Clustering example</h3>
<p>Let's first define a list of random coordinates in 3D space as an
example case:</p>
<pre><code class="language-crystal">coords <span class="o">=</span> [
  [<span class="n">-0.30818828</span>, <span class="n">2.70462841</span>, <span class="n">1.84344886</span>],
  [<span class="n">2.9666203</span>, <span class="n">-1.39874721</span>, <span class="n">4.76223947</span>],
  [<span class="n">3.21737027</span>, <span class="n">4.09489028</span>, <span class="n">-4.60403434</span>],
  [<span class="n">-3.51140292</span>, <span class="n">-0.83953645</span>, <span class="n">2.31887739</span>],
  [<span class="n">2.08457843</span>, <span class="n">4.24960773</span>, <span class="n">-3.91378835</span>],
  [<span class="n">2.88992367</span>, <span class="n">-0.97659082</span>, <span class="n">0.75464131</span>],
  [<span class="n">0.43808545</span>, <span class="n">3.70042294</span>, <span class="n">4.99126146</span>],
  [<span class="n">-1.71676206</span>, <span class="n">4.93399583</span>, <span class="n">0.27392482</span>],
  [<span class="n">1.12130963</span>, <span class="n">-1.09646418</span>, <span class="n">1.45833231</span>],
  [<span class="n">-3.45524705</span>, <span class="n">0.92812111</span>, <span class="n">0.15155981</span>],
]
labels <span class="o">=</span> (<span class="n">0</span>...coords.size).to_a <span class="c"># for demonstration purposes</span></code></pre>
<p>We'd like to group them by the proximity to each other defined by
Euclidean distance:</p>
<pre><code class="language-crystal"><span class="k">def</span> <span class="m">euclidean</span>(u, v)
  <span class="t">Math</span>.sqrt (<span class="n">0</span>...u.size).sum { <span class="o">|</span>i<span class="o">|</span> (u[i] <span class="o">-</span> v[i])<span class="o">**</span><span class="n">2</span> }
<span class="k">end</span></code></pre>
<p>Let's say we want to split the coordinates into groups with a distance
no more than 4. The easiest way is to use the <code><a href="HClust.html#cluster%28elements%3AIndexable%28T%29%2Ccutoff%3ANumber%2Crule%3ARule%3D%3Asingle%2C%26%3AT%2CT-%3EFloat64%29%3AArray%28Array%28T%29%29forallT-class-method">.cluster</a></code> convenience
method:</p>
<pre><code class="language-crystal">clusters <span class="o">=</span> <span class="t">HClust</span>.cluster(labels, <span class="n">4</span>) { <span class="o">|</span>i, j<span class="o">|</span> euclidean(coords[u], coords[v]) }
clusters.size <span class="c"># =&gt; 3</span>
clusters      <span class="c"># =&gt; [[0, 3, 6, 7, 9], [1, 5, 8], [2, 4]]</span></code></pre>
<p>The method receives the elements to be clustered, a distance cutoff,
and a block that receives two of the elements and must return the
dissimilarity between them. We observe that the coordinates can be
grouped into 3 distinct clusters containing 5, 3, and 2 elements,
respectively. The order of the clusters is arbitrary and depends on
the order of the elements.</p>
<p>Alternatively, one can set the maximum number of clusters to be
generated instead of a distance cutoff using the named argument
<code>into:</code>:</p>
<pre><code class="language-crystal">clusters <span class="o">=</span> <span class="t">HClust</span>.cluster(labels, into: <span class="n">2</span>) { <span class="o">|</span>i, j<span class="o">|</span> euclidean(coords[i], coords[j]) }
clusters.size <span class="c"># =&gt; 2</span>
clusters      <span class="c"># =&gt; [[0, 1, 3, 5, 6, 7, 8, 9], [2, 4]]</span></code></pre>
<p>As stated above, the linkage rule dictates how the dissimilarities are
updated upon merging two clusters during the clustering procedure.
Therefore, the clustering output will depend on the selected rule. In
turn, the choice of the linkage rule depends both on the problem
domain and performance requirements. By default, the single linkage is
used throughout the code but it can be given as the third (optional)
argument to the cluster methods if required.</p>
<pre><code class="language-crystal">clusters <span class="o">=</span> <span class="t">HClust</span>.cluster(labels, <span class="n">2</span>, <span class="n">:centroid</span>) { <span class="o">|</span>i, j<span class="o">|</span>
  euclidean(coords[i], coords[j])
}
clusters.size <span class="c"># =&gt; 5</span>
clusters      <span class="c"># =&gt; [[0, 7], [1, 5, 8], [2, 4], [3, 9], [6]]</span></code></pre>
<p>Note the different number of clusters and composition obtained with
the centroid linkage comparted to the previous result using the single
linkage.</p>
<h3><a id="advanced-usage" class="anchor" href="#advanced-usage">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Advanced usage</h3>
<p>Using the <code><a href="HClust.html#cluster%28elements%3AIndexable%28T%29%2Ccutoff%3ANumber%2Crule%3ARule%3D%3Asingle%2C%26%3AT%2CT-%3EFloat64%29%3AArray%28Array%28T%29%29forallT-class-method">.cluster</a></code> methods is enough in most cases, albeit obtaining
the dendrogram can be useful for visualization purposes or testing
different clustering arguments without recomputing the
dissimilarities.</p>
<p>Under the hood, the <code><a href="HClust.html#cluster%28elements%3AIndexable%28T%29%2Ccutoff%3ANumber%2Crule%3ARule%3D%3Asingle%2C%26%3AT%2CT-%3EFloat64%29%3AArray%28Array%28T%29%29forallT-class-method">.cluster</a></code> methods construct a <code><a href="HClust/DistanceMatrix.html">DistanceMatrix</a></code>
with the given block, invoke the <code><a href="HClust.html#linkage%28dism%3ADistanceMatrix%2Crule%3ARule%2Creuse%3ABool%3Dfalse%29%3ADendrogram-class-method">.linkage</a></code> method, and then call
<code><a href="HClust/Dendrogram.html#flatten%28height%3ANumber%29%3AArray%28Array%28Int32%29%29-instance-method">Dendrogram#flatten</a></code> on the obtained dendrogram with the given
argument. The latter returns an array of clusters, each containing a
list of indexes that can be used to fetch the original elements. The
equivalent code to the above example would be:</p>
<pre><code class="language-crystal">dism <span class="o">=</span> <span class="t">DistanceMatrix</span>.<span class="k">new</span>(coords.size) { <span class="o">|</span>i, j<span class="o">|</span> euclidean(coords[i], coords[j]) }
dendrogram <span class="o">=</span> linkage(dism)
clusters <span class="o">=</span> dendrogram.flatten(<span class="n">4</span>)</code></pre>
<p>The dendrogram represents the hierarchy as a series of merge steps,
which contain the merged clusters and computed dissimilarity. For
instance, let's see what the dendrogram looks like:</p>
<pre><code class="language-crystal">pp dendrogram.steps.map { <span class="o">|</span>s<span class="o">|</span> [s.clusters[<span class="n">0</span>], s.clusters[<span class="n">1</span>], s.distance, <span class="n">0.0</span>] }</code></pre>
<p>will print:</p>
<pre><code class="language-text"># cluster1, cluster2, dissimilarity, size (unused)
[[2, 4, 1.3355127737375514, 0.0],
 [5, 8, 1.9072352420201895, 0.0],
 [3, 9, 2.7973259058854163, 0.0],
 [0, 7, 3.068805125647255, 0.0],
 [6, 13, 3.384856775520168, 0.0],
 [1, 11, 3.796359969884454, 0.0],
 [12, 14, 3.9902939298123274, 0.0],
 [15, 16, 4.079225895869359, 0.0],
 [10, 17, 5.696974476555648, 0.0]]</code></pre>
<p>The output can be copied into a Python terminal and visualized using
the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.dendrogram.html">dendrogram</a> function in <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.fcluster.html">SciPy</a> or similar software. It would
look something like:</p>
<pre><code class="language-text">  |       ________________
5 |      |                |
  |      |                |
4 |      |         _______|_______
  |      |      __|__         ____|___
3 |      |     |     |       |      __|__
  |      |     |     |      _|_    |    _|_
2 |      |     |    _|_    |   |   |   |   |
  |      |     |   |   |   |   |   |   |   |
1 |     _|_    |   |   |   |   |   |   |   |
  |    |   |   |   |   |   |   |   |   |   |
0 |    2   4   1   5   8   3   9   6   0   7</code></pre>
<p>Using this graph, one can deduce the optimal cutoff for generating
flat clusters, where a cutoff = 4 would produce indeed two clusters as
shown above.</p>














  <h2>
    <a id="defined-in" class="anchor" href="#defined-in">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>
    Defined in:
  </h2>
  
    
      <a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust.cr#L214" target="_blank">
        hclust.cr
      </a>
    
    <br/>
  
    
      <a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/dendrogram.cr#L3" target="_blank">
        hclust/dendrogram.cr
      </a>
    
    <br/>
  
    
      <a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/version.cr#L1" target="_blank">
        hclust/version.cr
      </a>
    
    <br/>
  



  
    <h2>
      <a id="constant-summary" class="anchor" href="#constant-summary">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>
      Constant Summary
    </h2>
  
  <dl>
    
      <dt class="entry-const" id="VERSION">
        <strong>VERSION</strong> = <code>{{ (<span class="s">`shards version \&quot;/home/runner/work/hclust/hclust/src/hclust\&quot;`</span>).chomp.stringify }}</code>
      </dt>
      
    
  </dl>





  <h2>
    <a id="class-method-summary" class="anchor" href="#class-method-summary">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>
    Class Method Summary
  </h2>
  <ul class="list-summary">
    
      <li class="entry-summary">
        <a href="#cluster%28elements%3AIndexable%28T%29%2Ccutoff%3ANumber%2Crule%3ARule%3D%3Asingle%2C%26%3AT%2CT-%3EFloat64%29%3AArray%28Array%28T%29%29forallT-class-method" class="signature"><strong>.cluster</strong>(elements : Indexable(T), cutoff : Number, rule : Rule = <span class="n">:single</span>, & : T, T -> Float64) : Array(Array(T)) forall T</a>
        
          <div class="summary"><p>Clusters <em>elements</em> using the linkage rule <em>rule</em> based on the distances computed by the given block.</p></div>
        
      </li>
    
      <li class="entry-summary">
        <a href="#cluster%28elements%3AIndexable%28T%29%2C%2A%2Cintocount%3AInt%2Crule%3ARule%3D%3Asingle%2C%26%3AT%2CT-%3EFloat64%29%3AArray%28Array%28T%29%29forallT-class-method" class="signature"><strong>.cluster</strong>(elements : Indexable(T), *, into count : Int, rule : Rule = <span class="n">:single</span>, & : T, T -> Float64) : Array(Array(T)) forall T</a>
        
          <div class="summary"><p>Clusters <em>elements</em> into <em>count</em> clusters or fewer using the linkage rule <em>rule</em> based on the distances computed by the given block.</p></div>
        
      </li>
    
      <li class="entry-summary">
        <a href="#generic%28dism%3ADistanceMatrix%2Crule%3ARule%29%3ADendrogram-class-method" class="signature"><strong>.generic</strong>(dism : DistanceMatrix, rule : Rule) : Dendrogram</a>
        
          <div class="summary"><p>Perform hierarchical clustering based on the distances stored in <em>dism</em> using a fast generic linkage algorithm with the given linkage rule.</p></div>
        
      </li>
    
      <li class="entry-summary">
        <a href="#linkage%28dism%3ADistanceMatrix%2Crule%3ARule%2Creuse%3ABool%3Dfalse%29%3ADendrogram-class-method" class="signature"><strong>.linkage</strong>(dism : DistanceMatrix, rule : Rule, reuse : Bool = <span class="n">false</span>) : Dendrogram</a>
        
          <div class="summary"><p>Returns the hierarchical clustering based on the pairwise distances <em>dism</em> using the linkage rule <em>rule</em>.</p></div>
        
      </li>
    
      <li class="entry-summary">
        <a href="#mst%28dism%3ADistanceMatrix%29%3ADendrogram-class-method" class="signature"><strong>.mst</strong>(dism : DistanceMatrix) : Dendrogram</a>
        
          <div class="summary"><p>Perform hierarchical clustering based on the distances stored in <em>dism</em> using the minimum spanning tree (MST) algorithm.</p></div>
        
      </li>
    
      <li class="entry-summary">
        <a href="#nn_chain%28dism%3ADistanceMatrix%2Crule%3AChainRule%29%3ADendrogram-class-method" class="signature"><strong>.nn_chain</strong>(dism : DistanceMatrix, rule : ChainRule) : Dendrogram</a>
        
          <div class="summary"><p>Perform hierarchical clustering based on the distances stored in <em>dism</em> using the nearest-neighbor-chain (NN-chain) algorithm with the given linkage rule.</p></div>
        
      </li>
    
      <li class="entry-summary">
        <a href="#primitive%28dism%3ADistanceMatrix%2Crule%3ARule%29%3ADendrogram-class-method" class="signature"><strong>.primitive</strong>(dism : DistanceMatrix, rule : Rule) : Dendrogram</a>
        
          <div class="summary"><p>Perform hierarchical clustering based on the distances stored in <em>dism</em> using the classic algorithm with the given linkage rule.</p></div>
        
      </li>
    
  </ul>







<div class="methods-inherited">
  
</div>




  <h2>
    <a id="class-method-detail" class="anchor" href="#class-method-detail">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>
    Class Method Detail
  </h2>
  
    <div class="entry-detail" id="cluster(elements:Indexable(T),cutoff:Number,rule:Rule=:single,&amp;:T,T-&gt;Float64):Array(Array(T))forallT-class-method">
      <div class="signature">
        
        def self.<strong>cluster</strong>(elements : Indexable(T), cutoff : Number, rule : <a href="HClust/Rule.html">Rule</a> = <span class="n">:single</span>, & : T, T -> Float64) : Array(Array(T)) forall T

        <a class="method-permalink" href="#cluster%28elements%3AIndexable%28T%29%2Ccutoff%3ANumber%2Crule%3ARule%3D%3Asingle%2C%26%3AT%2CT-%3EFloat64%29%3AArray%28Array%28T%29%29forallT-class-method">#</a>
      </div>
      
        <div class="doc">
          
          <p>Clusters <em>elements</em> using the linkage rule <em>rule</em> based on the
distances computed by the given block. The clusters are generated such
that the cophenetic distance between any two elements in a cluster is
less than or equal to <em>cutoff</em>.</p>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/cluster.cr#L5" target="_blank">View source</a>]
        
      </div>
    </div>
  
    <div class="entry-detail" id="cluster(elements:Indexable(T),*,intocount:Int,rule:Rule=:single,&amp;:T,T-&gt;Float64):Array(Array(T))forallT-class-method">
      <div class="signature">
        
        def self.<strong>cluster</strong>(elements : Indexable(T), *, into count : Int, rule : <a href="HClust/Rule.html">Rule</a> = <span class="n">:single</span>, & : T, T -> Float64) : Array(Array(T)) forall T

        <a class="method-permalink" href="#cluster%28elements%3AIndexable%28T%29%2C%2A%2Cintocount%3AInt%2Crule%3ARule%3D%3Asingle%2C%26%3AT%2CT-%3EFloat64%29%3AArray%28Array%28T%29%29forallT-class-method">#</a>
      </div>
      
        <div class="doc">
          
          <p>Clusters <em>elements</em> into <em>count</em> clusters or fewer using the linkage
rule <em>rule</em> based on the distances computed by the given block.</p>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/cluster.cr#L24" target="_blank">View source</a>]
        
      </div>
    </div>
  
    <div class="entry-detail" id="generic(dism:DistanceMatrix,rule:Rule):Dendrogram-class-method">
      <div class="signature">
        
        def self.<strong>generic</strong>(dism : <a href="HClust/DistanceMatrix.html">DistanceMatrix</a>, rule : <a href="HClust/Rule.html">Rule</a>) : <a href="HClust/Dendrogram.html">Dendrogram</a>

        <a class="method-permalink" href="#generic%28dism%3ADistanceMatrix%2Crule%3ARule%29%3ADendrogram-class-method">#</a>
      </div>
      
        <div class="doc">
          
          <p>Perform hierarchical clustering based on the distances stored in
<em>dism</em> using a fast generic linkage algorithm with the given linkage
rule.</p>
<p>The so-called generic algorithm published by Müllner, D.
<a href="https://arxiv.org/abs/1109.2378">[1]</a> includes several optimizations
over the classic hierarchical clustering algorithm, reducing the
best-case complexity from Θ(<em>N</em>³) to Θ(<em>N</em>²). In practice, it is
considerably faster than the standard method. This is mainly due to
the algorithm keeps track of the nearest neighbors of clusters in a
priority queue to speed up the repeated minimum searches.</p>
<p>This algorithm can deal with inversions in the dendrogram, so it can
be used with any linkage rule including <code><a href="HClust/Rule.html#Centroid">Rule::Centroid</a></code> and
<code><a href="HClust/Rule.html#Median">Rule::Median</a></code>.</p>
<p>The merge steps are encoded as an unordered <code><a href="HClust/Dendrogram.html">Dendrogram</a></code>, which is
sorted prior to be returned.</p>
<p>The current implementation is described in section 3.1 of the
Müllner's article <a href="https://arxiv.org/abs/1109.2378">[1]</a>.</p>
<p><span class="flag purple">NOTE</span>  Prefer to use the <code><a href="HClust.html#linkage%28dism%3ADistanceMatrix%2Crule%3ARule%2Creuse%3ABool%3Dfalse%29%3ADendrogram-class-method">.linkage</a></code> method since it provides a general
interface and picks the best algorithm depending on the linkage rule.</p>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/generic.cr#L25" target="_blank">View source</a>]
        
      </div>
    </div>
  
    <div class="entry-detail" id="linkage(dism:DistanceMatrix,rule:Rule,reuse:Bool=false):Dendrogram-class-method">
      <div class="signature">
        
        def self.<strong>linkage</strong>(dism : <a href="HClust/DistanceMatrix.html">DistanceMatrix</a>, rule : <a href="HClust/Rule.html">Rule</a>, reuse : Bool = <span class="n">false</span>) : <a href="HClust/Dendrogram.html">Dendrogram</a>

        <a class="method-permalink" href="#linkage%28dism%3ADistanceMatrix%2Crule%3ARule%2Creuse%3ABool%3Dfalse%29%3ADendrogram-class-method">#</a>
      </div>
      
        <div class="doc">
          
          <p>Returns the hierarchical clustering based on the pairwise distances
<em>dism</em> using the linkage rule <em>rule</em>.</p>
<p>This method simply selects and invokes the optimal algorithm based on
the given linkage rule as follows:</p>
<ul>
<li>The minimum spanning tree (MST) algoritm for the <code><a href="HClust/Rule.html#Single">Rule::Single</a></code>
linkage rule (see <code><a href="HClust.html#mst%28dism%3ADistanceMatrix%29%3ADendrogram-class-method">.mst</a></code>).</li>
<li>The nearest-neighbor-chain (NN-chain) algoritm for the
<code><a href="HClust/Rule.html#Complete">Rule::Complete</a></code>, <code><a href="HClust/Rule.html#Average">Rule::Average</a></code>, <code><a href="HClust/Rule.html#Weighted">Rule::Weighted</a></code>, and
<code><a href="HClust/Rule.html#Ward">Rule::Ward</a></code> linkage rules (<code><a href="HClust.html#nn_chain%28dism%3ADistanceMatrix%2Crule%3AChainRule%29%3ADendrogram-class-method">.nn_chain</a></code>).</li>
<li>The generic algoritm for the <code><a href="HClust/Rule.html#Centroid">Rule::Centroid</a></code> and <code><a href="HClust/Rule.html#Median">Rule::Median</a></code>
linkage rules (<code><a href="HClust.html#generic%28dism%3ADistanceMatrix%2Crule%3ARule%29%3ADendrogram-class-method">.generic</a></code>).</li>
</ul>
<p>If <em>reuse</em> is <code>true</code>, the distance matrix <em>dism</em> will be forwarded
directly to the underlying method, and be potentially modified. If
<em>reuse</em> is <code>false</code>, a copy will be created first and then forwarded.
This can be used to prevent a potentially large memory allocation when
the distance matrix will not be used after clustering.</p>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/linkage.cr#L20" target="_blank">View source</a>]
        
      </div>
    </div>
  
    <div class="entry-detail" id="mst(dism:DistanceMatrix):Dendrogram-class-method">
      <div class="signature">
        
        def self.<strong>mst</strong>(dism : <a href="HClust/DistanceMatrix.html">DistanceMatrix</a>) : <a href="HClust/Dendrogram.html">Dendrogram</a>

        <a class="method-permalink" href="#mst%28dism%3ADistanceMatrix%29%3ADendrogram-class-method">#</a>
      </div>
      
        <div class="doc">
          
          <p>Perform hierarchical clustering based on the distances stored in
<em>dism</em> using the minimum spanning tree (MST) algorithm.</p>
<p>The MST algorithm keeps track of the distances to the nearest neighbor
for each cluster after every merge step, which leads to a significant
speed up as obtaining the next pair of nearest clusters is very
efficient. By definition, this algorithm can only be used with the
<code><a href="HClust/Rule.html#Single">Rule::Single</a></code> linkage rule.</p>
<p>The merge steps are encoded as an unordered <code><a href="HClust/Dendrogram.html">Dendrogram</a></code>, which is
sorted prior to be returned.</p>
<p>The current implementation is described in section 3.3 of the
Müllner's article <a href="https://arxiv.org/abs/1109.2378">[1]</a>, which
includes several optimizations over the classic implementation.</p>
<p><span class="flag purple">NOTE</span>  Prefer to use the <code><a href="HClust.html#linkage%28dism%3ADistanceMatrix%2Crule%3ARule%2Creuse%3ABool%3Dfalse%29%3ADendrogram-class-method">.linkage</a></code> method since it provides a general
interface and picks the best algorithm depending on the linkage rule.</p>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/mst.cr#L19" target="_blank">View source</a>]
        
      </div>
    </div>
  
    <div class="entry-detail" id="nn_chain(dism:DistanceMatrix,rule:ChainRule):Dendrogram-class-method">
      <div class="signature">
        
        def self.<strong>nn_chain</strong>(dism : <a href="HClust/DistanceMatrix.html">DistanceMatrix</a>, rule : <a href="HClust/ChainRule.html">ChainRule</a>) : <a href="HClust/Dendrogram.html">Dendrogram</a>

        <a class="method-permalink" href="#nn_chain%28dism%3ADistanceMatrix%2Crule%3AChainRule%29%3ADendrogram-class-method">#</a>
      </div>
      
        <div class="doc">
          
          <p>Perform hierarchical clustering based on the distances stored in
<em>dism</em> using the nearest-neighbor-chain (NN-chain) algorithm with the
given linkage rule.</p>
<p>The NN-chain algorithm follows paths in the nearest neighbor graph of
the clusters to find a pair of clusters that are nearest neighbors of
each other, which are merged into a new cluster. The algorithm uses a
stack data structure (<code>Deque</code>) to store the paths, which can lead to a
speed up by re-using parts of the existing path efficiently.</p>
<p>By definition, the NN-chain algorithm can only be used with the
following linkage rules: <code><a href="HClust/Rule.html#Single">Rule::Single</a></code>, <code><a href="HClust/Rule.html#Complete">Rule::Complete</a></code>,
<code><a href="HClust/Rule.html#Average">Rule::Average</a></code>, <code><a href="HClust/Rule.html#Weighted">Rule::Weighted</a></code>, and <code><a href="HClust/Rule.html#Ward">Rule::Ward</a></code>. Consequently,
this method accepts a <code><a href="HClust/ChainRule.html">ChainRule</a></code> enum (not <code><a href="HClust/Rule.html">Rule</a></code>), which only
contains these methods to ensure safety during compilation.</p>
<p>The merge steps are encoded as an unordered <code><a href="HClust/Dendrogram.html">Dendrogram</a></code>, which is
sorted prior to be returned.</p>
<p>The current implementation is described in section 3.2 of the
Müllner's article <a href="https://arxiv.org/abs/1109.2378">[1]</a>.</p>
<p><span class="flag purple">NOTE</span>  Prefer to use the <code><a href="HClust.html#linkage%28dism%3ADistanceMatrix%2Crule%3ARule%2Creuse%3ABool%3Dfalse%29%3ADendrogram-class-method">.linkage</a></code> method since it provides a general
interface and picks the best algorithm depending on the linkage rule.</p>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/chain.cr#L25" target="_blank">View source</a>]
        
      </div>
    </div>
  
    <div class="entry-detail" id="primitive(dism:DistanceMatrix,rule:Rule):Dendrogram-class-method">
      <div class="signature">
        
        def self.<strong>primitive</strong>(dism : <a href="HClust/DistanceMatrix.html">DistanceMatrix</a>, rule : <a href="HClust/Rule.html">Rule</a>) : <a href="HClust/Dendrogram.html">Dendrogram</a>

        <a class="method-permalink" href="#primitive%28dism%3ADistanceMatrix%2Crule%3ARule%29%3ADendrogram-class-method">#</a>
      </div>
      
        <div class="doc">
          
          <p>Perform hierarchical clustering based on the distances stored in
<em>dism</em> using the classic algorithm with the given linkage rule.</p>
<p>The classic or primitive algorithm iteratively finds a pair of
clusters that are nearest neighbors of each other, which are merged
into a new cluster. Then, the distances stored in <em>dism</em> are updated
by computing the distances to the newly-created cluster according to
the linkage rule. The procedure is repeated for <em>N</em> - 1 times, where
<em>N</em> is the number of elements or observations. Since all pairwise
distances are searched in each iteration, the time complexity of this
algorithm is Θ(<em>N</em>³).</p>
<p>This algorithm can deal with inversions in the dendrogram, so it can
be used with any linkage rule including <code><a href="HClust/Rule.html#Centroid">Rule::Centroid</a></code> and
<code><a href="HClust/Rule.html#Median">Rule::Median</a></code>.</p>
<p>The merge steps are encoded as an unordered <code><a href="HClust/Dendrogram.html">Dendrogram</a></code>, which is
sorted prior to be returned.</p>
<p>The current implementation is described in section 2.4 of the
Müllner's article <a href="https://arxiv.org/abs/1109.2378">[1]</a>.</p>
<p><span class="flag yellow">WARNING</span>  This method is painfully slow and should not be used for
production. It is only used as reference to test other methods. Prefer
to use the <code><a href="HClust.html#linkage%28dism%3ADistanceMatrix%2Crule%3ARule%2Creuse%3ABool%3Dfalse%29%3ADendrogram-class-method">.linkage</a></code> method since it provides a general interface and
picks the best algorithm depending on the linkage rule.</p>
        </div>
      
      <br/>
      <div>
        
          [<a href="https://github.com/franciscoadasme/hclust/blob/ec2563184f512bc1c54bfd08baba69587771d7cf/src/hclust/primitive.cr#L27" target="_blank">View source</a>]
        
      </div>
    </div>
  






</div>

</body>
</html>
